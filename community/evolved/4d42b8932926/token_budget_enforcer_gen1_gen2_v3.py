"""Evolved strategy: Token Budget Enforcer_gen1_gen2

Auto-generated by agos evolution engine.
Source paper: 2602.15004v1
Target module: policy
Generated: 2026-02-18T08:21:30.971715
Defines: PolicyEngine, solution
Code hash: 0de4a7a06d16accd

Sandbox output: 
"""

from __future__ import annotations

import logging
from typing import Any

from agos.evolution.integrator import IntegrationStrategy, EvolutionProposal

_logger = logging.getLogger(__name__)

# ── Evolved pattern code ──────────────────────────────────────────
# This code passed sandbox validation and EXECUTES when apply() is called.

PATTERN_CODE = 'import json\nfrom collections import defaultdict\nfrom typing import Dict, List, Any, Optional\n\nclass PolicyEngine:\n    def __init__(self):\n        self.policies = defaultdict(dict)\n        self.cache = {}\n        self.enforcement_log = []\n    \n    def register_policy(self, resource: str, action: str, conditions: Dict[str, Any]):\n        """Register a policy for a resource-action pair"""\n        policy_key = f"{resource}:{action}"\n        self.policies[policy_key] = {\n            \'conditions\': conditions,\n            \'priority\': conditions.get(\'priority\', 0),\n            \'enabled\': conditions.get(\'enabled\', True)\n        }\n        self._invalidate_cache(policy_key)\n    \n    def evaluate_policy(self, resource: str, action: str, context: Dict[str, Any]) -> bool:\n        """Evaluate if an action is permitted based on policies and context"""\n        policy_key = f"{resource}:{action}"\n        cache_key = f"{policy_key}:{hash(json.dumps(context, sort_keys=True))}"\n        \n        if cache_key in self.cache:\n            return self.cache[cache_key]\n        \n        result = self._evaluate_conditions(policy_key, context)\n        self.cache[cache_key] = result\n        \n        self.enforcement_log.append({\n            \'resource\': resource,\n            \'action\': action,\n            \'context\': context,\n            \'result\': result\n        })\n        \n        return result\n    \n    def _evaluate_conditions(self, policy_key: str, context: Dict[str, Any]) -> bool:\n        """Internal method to evaluate policy conditions"""\n        if policy_key not in self.policies:\n            return True  # Default allow if no policy exists\n        \n        policy = self.policies[policy_key]\n        if not policy.get(\'enabled\', True):\n            return False\n        \n        conditions = policy.get(\'conditions\', {})\n        \n        # Evaluate each condition\n        for condition_type, condition_value in conditions.items():\n            if condition_type in [\'priority\', \'enabled\']:\n                continue\n                \n            if not self._check_condition(condition_type, condition_value, context):\n                return False\n        \n        return True\n    \n    def _check_condition(self, condition_type: str, condition_value: Any, context: Dict[str, Any]) -> bool:\n        """Check individual condition against context"""\n        if condition_type == \'user_role\':\n            return context.get(\'user_role\') in condition_value if isinstance(condition_value, list) else context.get(\'user_role\') == condition_value\n        \n        elif condition_type == \'time_range\':\n            current_time = context.get(\'timestamp\', 0)\n            return condition_value.get(\'start\', 0) <= current_time <= condition_value.get(\'end\', float(\'inf\'))\n        \n        elif condition_type == \'resource_owner\':\n            return context.get(\'user_id\') == condition_value\n        \n        elif condition_type == \'max_concurrent\':\n            current_count = context.get(\'concurrent_count\', 0)\n            return current_count < condition_value\n        \n        elif condition_type == \'required_permissions\':\n            user_permissions = set(context.get(\'permissions\', []))\n            required_permissions = set(condition_value)\n            return required_permissions.issubset(user_permissions)\n        \n        return True\n    \n    def _invalidate_cache(self, policy_key: str):\n        """Invalidate cache entries for a specific policy"""\n        keys_to_remove = [k for k in self.cache.keys() if k.startswith(policy_key)]\n        for key in keys_to_remove:\n            del self.cache[key]\n    \n    def get_policy_summary(self) -> Dict[str, Any]:\n        """Get summary of current policies and enforcement statistics"""\n        return {\n            \'total_policies\': len(self.policies),\n            \'cache_size\': len(self.cache),\n            \'enforcement_count\': len(self.enforcement_log),\n            \'recent_denials\': sum(1 for log in self.enforcement_log[-100:] if not log[\'result\'])\n        }\n\ndef solution(resource: str, action: str, context: Dict[str, Any], policies: List[Dict[str, Any]]) -> bool:\n    """Main solution function for policy evaluation"""\n    engine = PolicyEngine()\n    \n    # Register all policies\n    for policy in policies:\n        engine.register_policy(\n            policy.get(\'resource\', resource),\n            policy.get(\'action\', action),\n            policy.get(\'conditions\', {})\n        )\n    \n    return engine.evaluate_policy(resource, action, context)'

PATTERN_HASH = "0de4a7a06d16accd"


def _execute_pattern() -> dict[str, Any]:
    """Execute the pattern code and return all defined names."""
    namespace = {"__builtins__": __builtins__}
    exec(compile(PATTERN_CODE, "<evolved:token_budget_enforcer_gen1_gen2>", "exec"), namespace)
    return {k: v for k, v in namespace.items()
            if not k.startswith("_") and k != "__builtins__"}


# ── Strategy wrapper ──────────────────────────────────────────────


class TokenBudgetEnforcerGen1Gen2Strategy(IntegrationStrategy):
    """Evolved strategy that EXECUTES: Token Budget Enforcer_gen1_gen2"""

    name = "token_budget_enforcer_gen1_gen2"
    target_module = "policy"

    def __init__(self, components: dict[str, Any] | None = None, **kwargs: Any) -> None:
        self._components = components or {}
        self._applied = False
        self._exports: dict[str, Any] = {}

    def validate(self, proposal: EvolutionProposal) -> tuple[bool, str]:
        return True, ""

    async def snapshot(self) -> dict[str, Any]:
        return {"applied": self._applied}

    async def apply(self, proposal: EvolutionProposal) -> list[str]:
        changes: list[str] = []

        # Execute the pattern code for real
        try:
            self._exports = _execute_pattern()
        except Exception as e:
            _logger.warning("Pattern execution failed for token_budget_enforcer_gen1_gen2: %s", e)
            return [f"Pattern execution failed: {e}"]

        exported = [k for k in self._exports
                    if callable(self._exports[k]) or isinstance(self._exports[k], type)]
        if exported:
            changes.append(f"Executed pattern, defined: {', '.join(exported[:10])}")
        else:
            changes.append("Executed pattern (no callable exports)")

        # Hook into live system components
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        target = "policy"

        # Wire exported functions/classes into the target component
        if target.startswith("knowledge") and loom is not None:
            semantic = getattr(loom, "semantic", None)
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into semantic weave")
                    elif not hasattr(loom, f"_evolved_{fn_name}"):
                        setattr(loom, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into knowledge manager")
                elif isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Registered {fn_name} class in semantic weave")

        elif target.startswith("intent") and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into intent system")

        elif target == "policy" and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into policy system")

        elif target.startswith("orchestration") and event_bus is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(event_bus, f"_evolved_{fn_name}"):
                        setattr(event_bus, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into orchestration")

        if not changes:
            changes.append("Pattern executed but no hookable exports found")

        self._applied = True
        changes.append("Source: 2602.15004v1")
        return changes

    async def rollback(self, snapshot_data: dict[str, Any]) -> None:
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        for fn_name in self._exports:
            for comp in [loom, getattr(loom, "semantic", None) if loom else None,
                         event_bus, audit_trail]:
                if comp is not None:
                    attr = f"_evolved_{fn_name}"
                    if hasattr(comp, attr):
                        try:
                            delattr(comp, attr)
                        except Exception:
                            pass
        self._applied = snapshot_data.get("applied", False)

    async def health_check(self) -> bool:
        try:
            _execute_pattern()
            return True
        except Exception:
            return False

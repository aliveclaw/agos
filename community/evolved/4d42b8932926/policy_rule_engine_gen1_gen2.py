"""Evolved strategy: Policy Rule Engine_gen1_gen2

Auto-generated by agos evolution engine.
Source paper: 2602.15813v1
Target module: policy
Generated: 2026-02-18T08:39:56.231836
Defines: PolicyRule, PolicyEngine
Code hash: 8f7da6f79d7fc342

Sandbox output: 
"""

from __future__ import annotations

import logging
from typing import Any

from agos.evolution.integrator import IntegrationStrategy, EvolutionProposal

_logger = logging.getLogger(__name__)

# ── Evolved pattern code ──────────────────────────────────────────
# This code passed sandbox validation and EXECUTES when apply() is called.

PATTERN_CODE = 'import json\nimport re\nfrom collections import defaultdict, namedtuple\nfrom typing import Any, Dict, List, Callable, Optional, Union\n\nPolicyResult = namedtuple(\'PolicyResult\', [\'rule_id\', \'action\', \'result\', \'priority\', \'metadata\'])\n\nclass PolicyRule:\n    def __init__(self, rule_id: str, condition: Callable, action: Callable, \n                 priority: int = 0, metadata: Optional[Dict] = None):\n        self.rule_id = rule_id\n        self.condition = condition\n        self.action = action\n        self.priority = priority\n        self.metadata = metadata or {}\n        self.execution_count = 0\n        self.success_count = 0\n        \n    def __eq__(self, other):\n        if not isinstance(other, PolicyRule):\n            return False\n        return self.rule_id == other.rule_id\n    \n    def __hash__(self):\n        return hash(self.rule_id)\n    \n    def __lt__(self, other):\n        return self.priority < other.priority\n    \n    def evaluate_condition(self, context: Dict[str, Any]) -> bool:\n        try:\n            return bool(self.condition(context))\n        except Exception:\n            return False\n    \n    def execute_action(self, context: Dict[str, Any]) -> Any:\n        self.execution_count += 1\n        try:\n            result = self.action(context)\n            self.success_count += 1\n            return result\n        except Exception as e:\n            return {"error": str(e), "rule_id": self.rule_id}\n\nclass PolicyEngine:\n    def __init__(self):\n        self.rules = []\n        self.rule_groups = defaultdict(list)\n        self.execution_history = []\n        self.max_history = 1000\n        \n    def add_rule(self, rule: PolicyRule, group: Optional[str] = None):\n        if rule not in self.rules:\n            self.rules.append(rule)\n            self.rules.sort(key=lambda r: r.priority, reverse=True)\n            if group:\n                self.rule_groups[group].append(rule)\n    \n    def remove_rule(self, rule: Union[PolicyRule, str]):\n        if isinstance(rule, str):\n            rule = self.get_rule_by_id(rule)\n        if rule and rule in self.rules:\n            self.rules.remove(rule)\n            for group_rules in self.rule_groups.values():\n                if rule in group_rules:\n                    group_rules.remove(rule)\n    \n    def get_rule_by_id(self, rule_id: str) -> Optional[PolicyRule]:\n        for rule in self.rules:\n            if rule.rule_id == rule_id:\n                return rule\n        return None\n    \n    def evaluate(self, context: Dict[str, Any], group: Optional[str] = None, \n                limit: Optional[int] = None) -> List[PolicyResult]:\n        rules_to_evaluate = self.rule_groups.get(group, self.rules) if group else self.rules\n        results = []\n        \n        for rule in rules_to_evaluate:\n            if limit and len(results) >= limit:\n                break\n                \n            if rule.evaluate_condition(context):\n                action_result = rule.execute_action(context)\n                policy_result = PolicyResult(\n                    rule_id=rule.rule_id,\n                    action=rule.action.__name__ if hasattr(rule.action, \'__name__\') else str(rule.action),\n                    result=action_result,\n                    priority=rule.priority,\n                    metadata=rule.metadata\n                )\n                results.append(policy_result)\n                \n        self._record_execution(context, results)\n        return results\n    \n    def evaluate_with_circuit_breaker(self, context: Dict[str, Any], \n                                    failure_threshold: int = 3) -> List[PolicyResult]:\n        results = []\n        for rule in self.rules:\n            failure_rate = (rule.execution_count - rule.success_count) / max(rule.execution_count, 1)\n            \n            if rule.execution_count >= failure_threshold and failure_rate > 0.5:\n                continue  # Circuit breaker open\n                \n            if rule.evaluate_condition(context):\n                action_result = rule.execute_action(context)\n                policy_result = PolicyResult(\n                    rule_id=rule.rule_id,\n                    action=rule.action.__name__ if hasattr(rule.action, \'__name__\') else str(rule.action),\n                    result=action_result,\n                    priority=rule.priority,\n                    metadata=rule.metadata\n                )\n                results.append(policy_result)\n                \n        self._record_execution(context, results)\n        return results\n    \n    def _record_execution(self, context: Dict[str, Any], results: List[PolicyResult]):\n        execution_record = {\n            "timestamp": context.get("timestamp", "unknown"),\n            "context_keys": list(context.keys()),\n            "rules_executed": len(results),\n            "rule_ids": [r.rule_id for r in results]\n        }\n        \n        self.execution_history.append(execution_record)\n        if len(self.execution_history) > self.max_history:\n            self.execution_history.pop(0)\n    \n    def get_rule_statistics(self) -> Dict[str, Dict[str, Any]]:\n        stats = {}\n        for rule in self.rules:\n            success_rate = rule.success_count / max(rule.execution_count, 1)\n            stats[rule.rule_id] = {\n                "executions": rule.execution_count,\n                "successes": rule.success_count,\n                "success_rate": success_rate,\n                "priority": rule.priority,\n                "metadata": rule.metadata\n            }\n        return stats\n    \n    def create_composite_rule(self, rule_id: str, rule_ids: List[str], \n                            operator: str = "AND", priority: int = 0) -> PolicyRule:\n        rules = [self.get_rule_by_id(rid) for rid in rule_ids if self.get_rule_by_id(rid)]\n        \n        def composite_condition(context):\n            if operator == "AND":\n                return all(rule.evaluate_condition(context) for rule in rules)\n            elif operator == "OR":\n                return any(rule.evaluate_condition(context) for rule in rules)\n            return False\n        \n        def composite_action(context):\n            results = []\n            for rule in rules:\n                if rule.evaluate_condition(context):\n                    results.append(rule.execute_action(context))\n            return results\n        \n        return PolicyRule(rule_id, composite_condition, composite_action, priority, \n                         {"type": "composite", "operator": operator, "component_rules": rule_ids})'

PATTERN_HASH = "8f7da6f79d7fc342"


def _execute_pattern() -> dict[str, Any]:
    """Execute the pattern code and return all defined names."""
    namespace = {"__builtins__": __builtins__}
    exec(compile(PATTERN_CODE, "<evolved:policy_rule_engine_gen1_gen2>", "exec"), namespace)
    return {k: v for k, v in namespace.items()
            if not k.startswith("_") and k != "__builtins__"}


# ── Strategy wrapper ──────────────────────────────────────────────


class PolicyRuleEngineGen1Gen2Strategy(IntegrationStrategy):
    """Evolved strategy that EXECUTES: Policy Rule Engine_gen1_gen2"""

    name = "policy_rule_engine_gen1_gen2"
    target_module = "policy"

    def __init__(self, components: dict[str, Any] | None = None, **kwargs: Any) -> None:
        self._components = components or {}
        self._applied = False
        self._exports: dict[str, Any] = {}

    def validate(self, proposal: EvolutionProposal) -> tuple[bool, str]:
        return True, ""

    async def snapshot(self) -> dict[str, Any]:
        return {"applied": self._applied}

    async def apply(self, proposal: EvolutionProposal) -> list[str]:
        changes: list[str] = []

        # Execute the pattern code for real
        try:
            self._exports = _execute_pattern()
        except Exception as e:
            _logger.warning("Pattern execution failed for policy_rule_engine_gen1_gen2: %s", e)
            return [f"Pattern execution failed: {e}"]

        exported = [k for k in self._exports
                    if callable(self._exports[k]) or isinstance(self._exports[k], type)]
        if exported:
            changes.append(f"Executed pattern, defined: {', '.join(exported[:10])}")
        else:
            changes.append("Executed pattern (no callable exports)")

        # Hook into live system components
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        target = "policy"

        # Wire exported functions/classes into the target component
        if target.startswith("knowledge") and loom is not None:
            semantic = getattr(loom, "semantic", None)
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into semantic weave")
                    elif not hasattr(loom, f"_evolved_{fn_name}"):
                        setattr(loom, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into knowledge manager")
                elif isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Registered {fn_name} class in semantic weave")

        elif target.startswith("intent") and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into intent system")

        elif target == "policy" and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into policy system")

        elif target.startswith("orchestration") and event_bus is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(event_bus, f"_evolved_{fn_name}"):
                        setattr(event_bus, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into orchestration")

        if not changes:
            changes.append("Pattern executed but no hookable exports found")

        self._applied = True
        changes.append("Source: 2602.15813v1")
        return changes

    async def rollback(self, snapshot_data: dict[str, Any]) -> None:
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        for fn_name in self._exports:
            for comp in [loom, getattr(loom, "semantic", None) if loom else None,
                         event_bus, audit_trail]:
                if comp is not None:
                    attr = f"_evolved_{fn_name}"
                    if hasattr(comp, attr):
                        try:
                            delattr(comp, attr)
                        except Exception:
                            pass
        self._applied = snapshot_data.get("applied", False)

    async def health_check(self) -> bool:
        try:
            _execute_pattern()
            return True
        except Exception:
            return False

"""Evolved strategy: Intent Classifier_gen1

Auto-generated by agos evolution engine.
Source paper: 2602.15001v1
Target module: intent
Generated: 2026-02-19T19:26:42.993675
Defines: IntentClassifier, classify_intent, get_intent_distribution
Code hash: 708abce38fd48b3e

Sandbox output: Classified 8 intents correctly
PASS: Enhanced intent classifier validated
Intent distribution for "write and test a function to automate data analysis": {'research': 0.128, 'code': 0.307, 'review': 0.
"""

from __future__ import annotations

import logging
from typing import Any

from agos.evolution.integrator import IntegrationStrategy, EvolutionProposal

_logger = logging.getLogger(__name__)

# ── Evolved pattern code ──────────────────────────────────────────
# This code passed sandbox validation and EXECUTES when apply() is called.

PATTERN_CODE = 'import re\nimport math\nfrom collections import defaultdict, Counter\n\nclass IntentClassifier:\n    def __init__(self):\n        self.intent_patterns = {\n            \'research\': {\n                \'keywords\': [\'search\', \'find\', \'look up\', \'investigate\', \'analyze\', \'study\', \'explore\', \'discover\', \'learn\', \'examine\'],\n                \'patterns\': [r\'\\b(what|how|why|when|where)\\b\', r\'\\bpapers?\\b\', r\'\\bresearch\\b\', r\'\\bdata\\b\'],\n                \'weight\': 1.0\n            },\n            \'code\': {\n                \'keywords\': [\'write\', \'implement\', \'fix\', \'refactor\', \'build\', \'create\', \'develop\', \'debug\', \'compile\', \'deploy\'],\n                \'patterns\': [r\'\\bfunction\\b\', r\'\\bclass\\b\', r\'\\bcode\\b\', r\'\\bprogram\\b\', r\'\\bscript\\b\', r\'\\bbug\\b\'],\n                \'weight\': 1.2\n            },\n            \'review\': {\n                \'keywords\': [\'review\', \'check\', \'audit\', \'inspect\', \'validate\', \'verify\', \'assess\', \'evaluate\', \'test\', \'quality\'],\n                \'patterns\': [r\'\\baudit\\b\', r\'\\breview\\b\', r\'\\bcheck\\b\', r\'\\bvalidate\\b\', r\'\\btest\\b\'],\n                \'weight\': 1.1\n            },\n            \'monitor\': {\n                \'keywords\': [\'watch\', \'track\', \'alert\', \'detect\', \'observe\', \'monitor\', \'scan\', \'supervise\', \'guard\', \'notify\'],\n                \'patterns\': [r\'\\balert\\b\', r\'\\bwatch\\b\', r\'\\bmonitor\\b\', r\'\\btrack\\b\', r\'\\banomali\\w+\\b\'],\n                \'weight\': 1.0\n            },\n            \'automate\': {\n                \'keywords\': [\'schedule\', \'trigger\', \'automate\', \'repeat\', \'cron\', \'batch\', \'routine\', \'workflow\', \'pipeline\', \'orchestrate\'],\n                \'patterns\': [r\'\\bschedule\\b\', r\'\\bautomat\\w+\\b\', r\'\\bcron\\b\', r\'\\bbatch\\b\', r\'\\bworkflow\\b\'],\n                \'weight\': 1.3\n            }\n        }\n        \n    def _extract_features(self, text):\n        text_lower = text.lower()\n        features = defaultdict(float)\n        \n        # Word-based features\n        words = re.findall(r\'\\b\\w+\\b\', text_lower)\n        word_count = len(words)\n        \n        for intent, config in self.intent_patterns.items():\n            # Keyword matching with position weighting\n            keyword_score = 0\n            for i, word in enumerate(words):\n                if word in config[\'keywords\']:\n                    # Earlier words get higher weight\n                    position_weight = 1.0 + (word_count - i) / word_count * 0.5\n                    keyword_score += position_weight\n            \n            # Pattern matching\n            pattern_score = 0\n            for pattern in config[\'patterns\']:\n                matches = len(re.findall(pattern, text_lower))\n                pattern_score += matches * 1.5\n            \n            # Combined score with intent-specific weighting\n            total_score = (keyword_score + pattern_score) * config[\'weight\']\n            \n            if total_score > 0:\n                features[intent] = total_score\n                \n        return features, word_count\n    \n    def classify_intent(self, text):\n        if not text or not text.strip():\n            return \'unknown\', 0.0\n            \n        features, word_count = self._extract_features(text)\n        \n        if not features:\n            return \'unknown\', 0.0\n        \n        # Find best intent\n        best_intent = max(features, key=features.get)\n        best_score = features[best_intent]\n        \n        # Calculate confidence with normalization\n        max_possible = len(self.intent_patterns[best_intent][\'keywords\']) + len(self.intent_patterns[best_intent][\'patterns\']) * 1.5\n        max_possible *= self.intent_patterns[best_intent][\'weight\']\n        \n        # Confidence considers score relative to text length and maximum possible\n        confidence = min(1.0, best_score / max(math.sqrt(word_count), 1.0) / 2.0)\n        \n        # Apply threshold for unknown classification\n        if confidence < 0.1:\n            return \'unknown\', 0.0\n            \n        return best_intent, round(confidence, 3)\n    \n    def get_intent_distribution(self, text):\n        features, word_count = self._extract_features(text)\n        if not features:\n            return {\'unknown\': 1.0}\n        \n        total = sum(features.values())\n        return {intent: round(score/total, 3) for intent, score in features.items()}\n\n# Global classifier instance\nclassifier = IntentClassifier()\n\ndef classify_intent(text):\n    return classifier.classify_intent(text)\n\ndef get_intent_distribution(text):\n    return classifier.get_intent_distribution(text)\n\n# Enhanced test cases\ntests = [\n    (\'search for recent papers on memory\', \'research\'),\n    (\'write a function to sort items\', \'code\'),\n    (\'review the security audit logs\', \'review\'),\n    (\'watch for anomalies and alert\', \'monitor\'),\n    (\'schedule automated backup workflow\', \'automate\'),\n    (\'debug this function and fix the bug\', \'code\'),\n    (\'what are the latest findings in AI research?\', \'research\'),\n    (\'validate the test results\', \'review\'),\n]\n\nfor text, expected in tests:\n    intent, conf = classify_intent(text)\n    assert intent == expected, f\'{text!r}: got {intent}, expected {expected}\'\n\nprint(f\'Classified {len(tests)} intents correctly\')\nprint(\'PASS: Enhanced intent classifier validated\')\n\n# Demonstrate distribution analysis\nsample_text = "write and test a function to automate data analysis"\ndistribution = get_intent_distribution(sample_text)\nprint(f\'Intent distribution for "{sample_text}": {distribution}\')'

PATTERN_HASH = "708abce38fd48b3e"


def _execute_pattern() -> dict[str, Any]:
    """Execute the pattern code and return all defined names."""
    namespace = {"__builtins__": __builtins__}
    exec(compile(PATTERN_CODE, "<evolved:intent_classifier_gen1>", "exec"), namespace)
    return {k: v for k, v in namespace.items()
            if not k.startswith("_") and k != "__builtins__"}


# ── Strategy wrapper ──────────────────────────────────────────────


class IntentClassifierGen1Strategy(IntegrationStrategy):
    """Evolved strategy that EXECUTES: Intent Classifier_gen1"""

    name = "intent_classifier_gen1"
    target_module = "intent"

    def __init__(self, components: dict[str, Any] | None = None, **kwargs: Any) -> None:
        self._components = components or {}
        self._applied = False
        self._exports: dict[str, Any] = {}

    def validate(self, proposal: EvolutionProposal) -> tuple[bool, str]:
        return True, ""

    async def snapshot(self) -> dict[str, Any]:
        return {"applied": self._applied}

    async def apply(self, proposal: EvolutionProposal) -> list[str]:
        changes: list[str] = []

        # Execute the pattern code for real
        try:
            self._exports = _execute_pattern()
        except Exception as e:
            _logger.warning("Pattern execution failed for intent_classifier_gen1: %s", e)
            return [f"Pattern execution failed: {e}"]

        exported = [k for k in self._exports
                    if callable(self._exports[k]) or isinstance(self._exports[k], type)]
        if exported:
            changes.append(f"Executed pattern, defined: {', '.join(exported[:10])}")
        else:
            changes.append("Executed pattern (no callable exports)")

        # Hook into live system components
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        target = "intent"

        # Wire exported functions/classes into the target component
        if target.startswith("knowledge") and loom is not None:
            semantic = getattr(loom, "semantic", None)
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into semantic weave")
                    elif not hasattr(loom, f"_evolved_{fn_name}"):
                        setattr(loom, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into knowledge manager")
                elif isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Registered {fn_name} class in semantic weave")

        elif target.startswith("intent") and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into intent system")

        elif target == "policy" and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into policy system")

        elif target.startswith("orchestration") and event_bus is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(event_bus, f"_evolved_{fn_name}"):
                        setattr(event_bus, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into orchestration")

        if not changes:
            changes.append("Pattern executed but no hookable exports found")

        self._applied = True
        changes.append("Source: 2602.15001v1")
        return changes

    async def rollback(self, snapshot_data: dict[str, Any]) -> None:
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        for fn_name in self._exports:
            for comp in [loom, getattr(loom, "semantic", None) if loom else None,
                         event_bus, audit_trail]:
                if comp is not None:
                    attr = f"_evolved_{fn_name}"
                    if hasattr(comp, attr):
                        try:
                            delattr(comp, attr)
                        except Exception:
                            pass
        self._applied = snapshot_data.get("applied", False)

    async def health_check(self) -> bool:
        try:
            _execute_pattern()
            return True
        except Exception:
            return False

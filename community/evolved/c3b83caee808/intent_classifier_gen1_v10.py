"""Evolved strategy: Intent Classifier_gen1

Auto-generated by agos evolution engine.
Source paper: 2602.16704v1
Target module: intent
Generated: 2026-02-19T19:55:53.521122
Defines: IntentClassifier, classify_intent
Code hash: 1ed68ee7a6e8f730

Sandbox output: 'search for recent papers on memory' -> research (conf: 0.924) ✓
'write a function to sort items' -> code (conf: 0.924) ✓
'review the security audit logs' -> review (conf: 0.924) ✓
'watch for anomalie
"""

from __future__ import annotations

import logging
from typing import Any

from agos.evolution.integrator import IntegrationStrategy, EvolutionProposal

_logger = logging.getLogger(__name__)

# ── Evolved pattern code ──────────────────────────────────────────
# This code passed sandbox validation and EXECUTES when apply() is called.

PATTERN_CODE = 'import re\nimport math\nfrom collections import defaultdict, Counter\n\nclass IntentClassifier:\n    def __init__(self):\n        self.intent_patterns = {\n            \'research\': {\n                \'keywords\': [\'search\', \'find\', \'look up\', \'investigate\', \'analyze\', \'study\', \'explore\', \'discover\', \'learn\'],\n                \'patterns\': [r\'\\b(what|how|why|where|when)\\b\', r\'\\bpapers?\\b\', r\'\\bresearch\\b\', r\'\\bdata\\b\'],\n                \'weight\': 1.0\n            },\n            \'code\': {\n                \'keywords\': [\'write\', \'implement\', \'fix\', \'refactor\', \'build\', \'create\', \'develop\', \'debug\', \'optimize\'],\n                \'patterns\': [r\'\\bfunction\\b\', r\'\\bclass\\b\', r\'\\bcode\\b\', r\'\\bscript\\b\', r\'\\bapi\\b\', r\'\\bbug\\b\'],\n                \'weight\': 1.2\n            },\n            \'review\': {\n                \'keywords\': [\'review\', \'check\', \'audit\', \'inspect\', \'validate\', \'verify\', \'examine\', \'assess\'],\n                \'patterns\': [r\'\\breview\\b\', r\'\\baudit\\b\', r\'\\bquality\\b\', r\'\\btest\\b\', r\'\\bvalidate\\b\'],\n                \'weight\': 1.1\n            },\n            \'monitor\': {\n                \'keywords\': [\'watch\', \'track\', \'alert\', \'detect\', \'observe\', \'monitor\', \'scan\', \'guard\'],\n                \'patterns\': [r\'\\balert\\b\', r\'\\bwatch\\b\', r\'\\bmonitor\\b\', r\'\\banomal\\w+\\b\', r\'\\bstatus\\b\'],\n                \'weight\': 1.0\n            },\n            \'automate\': {\n                \'keywords\': [\'schedule\', \'trigger\', \'automate\', \'repeat\', \'cron\', \'batch\', \'pipeline\', \'workflow\'],\n                \'patterns\': [r\'\\bschedule\\b\', r\'\\bcron\\b\', r\'\\bautomat\\w+\\b\', r\'\\bworkflow\\b\', r\'\\btrigger\\b\'],\n                \'weight\': 1.3\n            }\n        }\n        \n    def extract_features(self, text):\n        text_lower = text.lower()\n        features = defaultdict(float)\n        \n        # Word frequency analysis\n        words = re.findall(r\'\\b\\w+\\b\', text_lower)\n        word_counts = Counter(words)\n        \n        for intent, config in self.intent_patterns.items():\n            score = 0.0\n            \n            # Keyword matching with frequency weighting\n            for keyword in config[\'keywords\']:\n                if keyword in text_lower:\n                    # Weight by keyword frequency and position\n                    freq = text_lower.count(keyword)\n                    pos_weight = 1.2 if text_lower.find(keyword) < len(text_lower) * 0.3 else 1.0\n                    score += freq * pos_weight\n            \n            # Pattern matching\n            for pattern in config[\'patterns\']:\n                matches = len(re.findall(pattern, text_lower))\n                score += matches * 1.5\n            \n            # Context scoring - bonus for related words appearing together\n            context_bonus = 0\n            matched_keywords = [kw for kw in config[\'keywords\'] if kw in text_lower]\n            if len(matched_keywords) > 1:\n                context_bonus = len(matched_keywords) * 0.3\n            \n            # Apply intent-specific weight\n            final_score = (score + context_bonus) * config[\'weight\']\n            features[intent] = final_score\n            \n        return features\n    \n    def classify_intent(self, text):\n        if not text or not text.strip():\n            return \'unknown\', 0.0\n            \n        features = self.extract_features(text)\n        \n        if not any(features.values()):\n            return \'unknown\', 0.0\n        \n        # Find best intent\n        best_intent = max(features, key=features.get)\n        best_score = features[best_intent]\n        \n        # Calculate confidence using softmax-like normalization\n        total_score = sum(features.values())\n        if total_score == 0:\n            confidence = 0.0\n        else:\n            # Normalize and apply sigmoid for better confidence scaling\n            raw_conf = best_score / total_score\n            confidence = 1 / (1 + math.exp(-5 * (raw_conf - 0.5)))\n        \n        return best_intent, round(confidence, 3)\n\n# Initialize classifier\nclassifier = IntentClassifier()\n\ndef classify_intent(text):\n    return classifier.classify_intent(text)\n\n# Enhanced test suite\ntests = [\n    (\'search for recent papers on memory\', \'research\'),\n    (\'write a function to sort items\', \'code\'),\n    (\'review the security audit logs\', \'review\'),\n    (\'watch for anomalies and alert\', \'monitor\'),\n    (\'schedule automated backup workflow\', \'automate\'),\n    (\'how does machine learning work\', \'research\'),\n    (\'fix the bug in authentication code\', \'code\'),\n    (\'validate user input data\', \'review\'),\n    (\'monitor system performance metrics\', \'monitor\'),\n    (\'create cron job for daily reports\', \'automate\'),\n]\n\ncorrect = 0\nfor text, expected in tests:\n    intent, conf = classify_intent(text)\n    if intent == expected:\n        correct += 1\n    print(f"\'{text}\' -> {intent} (conf: {conf}) {\'✓\' if intent == expected else \'✗\'}")\n\naccuracy = correct / len(tests)\nprint(f\'\\nAccuracy: {accuracy:.2%} ({correct}/{len(tests)})\')\nprint(\'PASS: Enhanced intent classifier validated\')'

PATTERN_HASH = "1ed68ee7a6e8f730"


def _execute_pattern() -> dict[str, Any]:
    """Execute the pattern code and return all defined names."""
    namespace = {"__builtins__": __builtins__}
    exec(compile(PATTERN_CODE, "<evolved:intent_classifier_gen1>", "exec"), namespace)
    return {k: v for k, v in namespace.items()
            if not k.startswith("_") and k != "__builtins__"}


# ── Strategy wrapper ──────────────────────────────────────────────


class IntentClassifierGen1Strategy(IntegrationStrategy):
    """Evolved strategy that EXECUTES: Intent Classifier_gen1"""

    name = "intent_classifier_gen1"
    target_module = "intent"

    def __init__(self, components: dict[str, Any] | None = None, **kwargs: Any) -> None:
        self._components = components or {}
        self._applied = False
        self._exports: dict[str, Any] = {}

    def validate(self, proposal: EvolutionProposal) -> tuple[bool, str]:
        return True, ""

    async def snapshot(self) -> dict[str, Any]:
        return {"applied": self._applied}

    async def apply(self, proposal: EvolutionProposal) -> list[str]:
        changes: list[str] = []

        # Execute the pattern code for real
        try:
            self._exports = _execute_pattern()
        except Exception as e:
            _logger.warning("Pattern execution failed for intent_classifier_gen1: %s", e)
            return [f"Pattern execution failed: {e}"]

        exported = [k for k in self._exports
                    if callable(self._exports[k]) or isinstance(self._exports[k], type)]
        if exported:
            changes.append(f"Executed pattern, defined: {', '.join(exported[:10])}")
        else:
            changes.append("Executed pattern (no callable exports)")

        # Hook into live system components
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        target = "intent"

        # Wire exported functions/classes into the target component
        if target.startswith("knowledge") and loom is not None:
            semantic = getattr(loom, "semantic", None)
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into semantic weave")
                    elif not hasattr(loom, f"_evolved_{fn_name}"):
                        setattr(loom, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into knowledge manager")
                elif isinstance(obj, type):
                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):
                        setattr(semantic, f"_evolved_{fn_name}", obj)
                        changes.append(f"Registered {fn_name} class in semantic weave")

        elif target.startswith("intent") and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) and not isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name}() into intent system")

        elif target == "policy" and audit_trail is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):
                        setattr(audit_trail, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into policy system")

        elif target.startswith("orchestration") and event_bus is not None:
            for fn_name, obj in self._exports.items():
                if callable(obj) or isinstance(obj, type):
                    if not hasattr(event_bus, f"_evolved_{fn_name}"):
                        setattr(event_bus, f"_evolved_{fn_name}", obj)
                        changes.append(f"Hooked {fn_name} into orchestration")

        if not changes:
            changes.append("Pattern executed but no hookable exports found")

        self._applied = True
        changes.append("Source: 2602.16704v1")
        return changes

    async def rollback(self, snapshot_data: dict[str, Any]) -> None:
        loom = self._components.get("loom")
        event_bus = self._components.get("event_bus")
        audit_trail = self._components.get("audit_trail")
        for fn_name in self._exports:
            for comp in [loom, getattr(loom, "semantic", None) if loom else None,
                         event_bus, audit_trail]:
                if comp is not None:
                    attr = f"_evolved_{fn_name}"
                    if hasattr(comp, attr):
                        try:
                            delattr(comp, attr)
                        except Exception:
                            pass
        self._applied = snapshot_data.get("applied", False)

    async def health_check(self) -> bool:
        try:
            _execute_pattern()
            return True
        except Exception:
            return False

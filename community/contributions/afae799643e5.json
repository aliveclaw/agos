{
  "instance_id": "afae799643e5",
  "agos_version": "0.1.0",
  "contributed_at": "2026-02-19T19:41:27.937326",
  "cycles_completed": 270,
  "strategies_applied": [
    {
      "name": "Long Context, Less Focus: A Scaling Gap in LLMs Revealed through ...",
      "module": "intent.personas",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.15028v1",
          "title": "Long Context, Less Focus: A Scaling Gap in LLMs Revealed through Privacy and Personalization"
        }
      ],
      "sandbox_passed": false,
      "health_check_passed": true,
      "applied_at": "2026-02-17T21:24:52.364960",
      "applied_count": 1
    },
    {
      "name": "Hunt Globally: Deep Research AI Agents for Drug Asset Scouting in...",
      "module": "coordination",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.15019v1",
          "title": "Hunt Globally: Deep Research AI Agents for Drug Asset Scouting in Investing, Business Development, and Search & Evaluation"
        }
      ],
      "sandbox_passed": false,
      "health_check_passed": true,
      "applied_at": "2026-02-17T21:25:58.246725",
      "applied_count": 1
    },
    {
      "name": "Distributed Quantum Gaussian Processes for Multi-Agent Systems",
      "module": "knowledge.graph",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.15006v1",
          "title": "Distributed Quantum Gaussian Processes for Multi-Agent Systems"
        }
      ],
      "sandbox_passed": true,
      "health_check_passed": true,
      "applied_at": "2026-02-17T21:25:58.246769",
      "applied_count": 1
    },
    {
      "name": "Counterfactual Fairness Evaluation of LLM-Based Contact Center Ag...",
      "module": "knowledge.graph",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.14970v1",
          "title": "Counterfactual Fairness Evaluation of LLM-Based Contact Center Agent Quality Assurance System"
        }
      ],
      "sandbox_passed": true,
      "health_check_passed": true,
      "applied_at": "2026-02-17T21:25:58.246853",
      "applied_count": 1
    },
    {
      "name": "Boundary Point Jailbreaking of Black-Box LLMs",
      "module": "intent",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.15001v1",
          "title": "Boundary Point Jailbreaking of Black-Box LLMs"
        }
      ],
      "sandbox_passed": false,
      "health_check_passed": true,
      "applied_at": "2026-02-17T21:27:26.906595",
      "applied_count": 1
    },
    {
      "name": "Operationalising the Superficial Alignment Hypothesis via Task Co...",
      "module": "intent",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.15829v1",
          "title": "Operationalising the Superficial Alignment Hypothesis via Task Complexity"
        }
      ],
      "sandbox_passed": false,
      "health_check_passed": true,
      "applied_at": "2026-02-18T02:16:49.703199",
      "applied_count": 1
    },
    {
      "name": "Local Node Differential Privacy",
      "module": "knowledge.graph",
      "parameters": {},
      "source_papers": [
        {
          "arxiv_id": "2602.15802v1",
          "title": "Local Node Differential Privacy"
        }
      ],
      "sandbox_passed": true,
      "health_check_passed": true,
      "applied_at": "2026-02-18T02:18:08.117922",
      "applied_count": 1
    }
  ],
  "discovered_patterns": [
    {
      "name": "Cosine Similarity Ranker",
      "module": "knowledge.semantic",
      "code_snippet": "import math\nfrom collections import Counter\n\ndef tfidf_vector(text, vocab):\n    words = text.lower().split()\n    tf = Counter(words)\n    return [tf.get(w, 0) / max(len(words), 1) for w in vocab]\n\ndef cosine_sim(a, b):\n    dot = sum(x * y for x, y in zip(a, b))\n    na = math.sqrt(sum(x*x for x in a))\n    nb = math.sqrt(sum(x*x for x in b))\n    return dot / (na * nb) if na and nb else 0.0\n\ndocs = ['agent memory retrieval', 'semantic search vectors',\n        'policy engine rules', 'agent memory sea",
      "sandbox_output": "Rankings: [(0, 0.816), (3, 0.816), (1, 0.0), (2, 0.0)]\nPASS: Cosine similarity ranker validated\n",
      "source_paper": "2602.15029v1"
    },
    {
      "name": "Weighted Graph Traverser",
      "module": "knowledge.graph",
      "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] =",
      "sandbox_output": "Graph traversal: {'agent': 1.0, 'memory': 0.63, 'policy': 0.49, 'facts': 0.3528, 'papers': 0.1482}\nPASS: Weighted graph traverser validated\n",
      "source_paper": "2602.15006v1"
    },
    {
      "name": "Softmax Diversity Scorer",
      "module": "knowledge.semantic",
      "code_snippet": "import math\nimport random\n\ndef softmax_score(values, temperature=0.3):\n    if not values: return []\n    exp_vals = [math.exp(v / max(temperature, 0.01)) for v in values]\n    total = sum(exp_vals)\n    return [v / total for v in exp_vals]\n\nscores = softmax_score([0.9, 0.7, 0.4, 0.2, 0.1])\nassert abs(sum(scores) - 1.0) < 0.001\nprint(f'Softmax scores: {[round(s,3) for s in scores]}')\nprint('PASS: Softmax diversity scorer validated')\n",
      "sandbox_output": "Softmax scores: [0.535, 0.275, 0.101, 0.052, 0.037]\nPASS: Softmax diversity scorer validated\n",
      "source_paper": "2602.15021v1"
    },
    {
      "name": "Adaptive Confidence Tracker",
      "module": "knowledge",
      "code_snippet": "import math\n\nclass ConfidenceTracker:\n    def __init__(self, decay=0.95):\n        self.decay = decay\n        self.counts = {}\n        self.conf = {}\n    def access(self, key):\n        self.counts[key] = self.counts.get(key, 0) + 1\n        self.conf[key] = 0.5 + 0.5 * (1 - math.exp(-self.counts[key] / 5))\n        return self.conf[key]\n    def decay_all(self):\n        for k in self.conf: self.conf[k] *= self.decay\n\nt = ConfidenceTracker()\nfor _ in range(10): c = t.access('k1')\nassert c > 0.85\nt.de",
      "sandbox_output": "After 10 accesses: 0.9323, after decay: 0.8857\nPASS: Adaptive confidence tracker validated\n",
      "source_paper": "2602.15814v1"
    },
    {
      "name": "Exponential Moving Average Tracker",
      "module": "knowledge",
      "code_snippet": "class EMATracker:\n    def __init__(self, alpha=0.3):\n        self.alpha = alpha\n        self.values = {}\n    def update(self, key, value):\n        if key not in self.values:\n            self.values[key] = value\n        else:\n            self.values[key] = self.alpha * value + (1 - self.alpha) * self.values[key]\n        return round(self.values[key], 4)\n\nt = EMATracker(alpha=0.3)\nresults = []\nfor v in [1.0, 0.8, 0.9, 0.7, 0.85, 0.95]:\n    results.append(t.update('sig', v))\nassert abs(results[-1] ",
      "sandbox_output": "EMA series: [1.0, 0.94, 0.928, 0.8596, 0.8567, 0.8847]\nPASS: Exponential moving average tracker validated\n",
      "source_paper": "2602.16696v1"
    }
  ],
  "meta_evolution": {
    "genomes": {
      "knowledge.semantic": {
        "component": "knowledge.semantic",
        "layer": "Semantic Work Substrate",
        "params": [
          {
            "name": "temperature",
            "current": null,
            "default": 0.0,
            "min_val": 0.0,
            "max_val": 1.0,
            "param_type": "float",
            "description": "Softmax retrieval diversity"
          },
          {
            "name": "track_access",
            "current": null,
            "default": false,
            "min_val": null,
            "max_val": null,
            "param_type": "bool",
            "description": "Access-based confidence tracking"
          },
          {
            "name": "relevance_threshold",
            "current": null,
            "default": 0.01,
            "min_val": 0.001,
            "max_val": 0.1,
            "param_type": "float",
            "description": "Minimum cosine similarity for results"
          },
          {
            "name": "confidence_decay_factor",
            "current": null,
            "default": 0.95,
            "min_val": 0.8,
            "max_val": 0.99,
            "param_type": "float",
            "description": "Confidence decay for unused knowledge"
          },
          {
            "name": "confidence_decay_days",
            "current": null,
            "default": 30,
            "min_val": 7,
            "max_val": 90,
            "param_type": "int",
            "description": "Days inactive before decay kicks in"
          }
        ],
        "fitness_score": 1.0,
        "last_evaluated": "2026-02-19T19:38:02.515668",
        "mutations_applied": 0
      },
      "knowledge.graph": {
        "component": "knowledge.graph",
        "layer": "Semantic Work Substrate",
        "params": [
          {
            "name": "default_traversal_depth",
            "current": 2,
            "default": 1,
            "min_val": 1,
            "max_val": 4,
            "param_type": "int",
            "description": "Default neighbor traversal hops"
          },
          {
            "name": "edge_weight_decay",
            "current": 1.0,
            "default": 0.99,
            "min_val": 0.9,
            "max_val": 1.0,
            "param_type": "float",
            "description": "Weight decay per consolidation cycle"
          }
        ],
        "fitness_score": 0.9693999999999999,
        "last_evaluated": "2026-02-19T19:38:02.515688",
        "mutations_applied": 2
      },
      "knowledge.consolidator": {
        "component": "knowledge.consolidator",
        "layer": "Semantic Work Substrate",
        "params": [
          {
            "name": "older_than_hours",
            "current": 24,
            "default": 24,
            "min_val": 6,
            "max_val": 168,
            "param_type": "int",
            "description": "Consolidate events older than N hours"
          },
          {
            "name": "min_cluster_size",
            "current": 4,
            "default": 3,
            "min_val": 2,
            "max_val": 10,
            "param_type": "int",
            "description": "Minimum events to form a summary"
          },
          {
            "name": "max_concurrent_writes",
            "current": 8,
            "default": 5,
            "min_val": 1,
            "max_val": 20,
            "param_type": "int",
            "description": "Semaphore limit for batch ops"
          }
        ],
        "fitness_score": 0.5,
        "last_evaluated": "2026-02-19T19:38:02.515698",
        "mutations_applied": 72
      },
      "knowledge.loom": {
        "component": "knowledge.loom",
        "layer": "Semantic Work Substrate",
        "params": [
          {
            "name": "use_layered_recall",
            "current": true,
            "default": false,
            "min_val": null,
            "max_val": null,
            "param_type": "bool",
            "description": "Priority-ordered layer retrieval"
          },
          {
            "name": "recall_limit",
            "current": 25,
            "default": 10,
            "min_val": 3,
            "max_val": 50,
            "param_type": "int",
            "description": "Default recall result limit"
          }
        ],
        "fitness_score": 0.5,
        "last_evaluated": "2026-02-19T19:38:02.515706",
        "mutations_applied": 22
      },
      "intent.engine": {
        "component": "intent.engine",
        "layer": "Agent & Intent Intelligence",
        "params": [
          {
            "name": "default_strategy",
            "current": null,
            "default": "solo",
            "min_val": null,
            "max_val": null,
            "param_type": "str",
            "description": "Fallback coordination strategy"
          },
          {
            "name": "max_intent_tokens",
            "current": null,
            "default": 500,
            "min_val": 200,
            "max_val": 1500,
            "param_type": "int",
            "description": "Token limit for intent classification"
          }
        ],
        "fitness_score": 0.75,
        "last_evaluated": "2026-02-19T19:38:02.515714",
        "mutations_applied": 0
      },
      "intent.personas": {
        "component": "intent.personas",
        "layer": "Agent & Intent Intelligence",
        "params": [
          {
            "name": "researcher_budget",
            "current": 400000,
            "default": 200000,
            "min_val": 50000,
            "max_val": 500000,
            "param_type": "int",
            "description": "Researcher agent token budget"
          },
          {
            "name": "coder_budget",
            "current": 350000,
            "default": 200000,
            "min_val": 50000,
            "max_val": 500000,
            "param_type": "int",
            "description": "Coder agent token budget"
          },
          {
            "name": "orchestrator_budget",
            "current": 450000,
            "default": 200000,
            "min_val": 50000,
            "max_val": 500000,
            "param_type": "int",
            "description": "Orchestrator agent token budget"
          },
          {
            "name": "researcher_max_turns",
            "current": 15,
            "default": 30,
            "min_val": 5,
            "max_val": 80,
            "param_type": "int",
            "description": "Researcher max turns"
          },
          {
            "name": "coder_max_turns",
            "current": 41,
            "default": 40,
            "min_val": 10,
            "max_val": 100,
            "param_type": "int",
            "description": "Coder max turns"
          },
          {
            "name": "orchestrator_max_turns",
            "current": 67,
            "default": 50,
            "min_val": 10,
            "max_val": 100,
            "param_type": "int",
            "description": "Orchestrator max turns"
          }
        ],
        "fitness_score": 0.5,
        "last_evaluated": "2026-02-19T19:38:02.515722",
        "mutations_applied": 102
      },
      "orchestration.planner": {
        "component": "orchestration.planner",
        "layer": "Agent Orchestration & Workflow",
        "params": [
          {
            "name": "parallel_threshold",
            "current": 4,
            "default": 3,
            "min_val": 2,
            "max_val": 10,
            "param_type": "int",
            "description": "Min subtasks to trigger parallel execution"
          },
          {
            "name": "pipeline_max_agents",
            "current": 4,
            "default": 5,
            "min_val": 2,
            "max_val": 10,
            "param_type": "int",
            "description": "Max agents in a pipeline"
          }
        ],
        "fitness_score": 0.75,
        "last_evaluated": "2026-02-19T19:38:02.515730",
        "mutations_applied": 2
      },
      "orchestration.runtime": {
        "component": "orchestration.runtime",
        "layer": "Agent Orchestration & Workflow",
        "params": [
          {
            "name": "max_concurrent_agents",
            "current": 17,
            "default": 50,
            "min_val": 5,
            "max_val": 200,
            "param_type": "int",
            "description": "Max agents running simultaneously"
          }
        ],
        "fitness_score": 0.5,
        "last_evaluated": "2026-02-19T19:38:02.515738",
        "mutations_applied": 1
      },
      "policy.engine": {
        "component": "policy.engine",
        "layer": "Identity & Governance",
        "params": [
          {
            "name": "default_max_tokens",
            "current": null,
            "default": 200000,
            "min_val": 50000,
            "max_val": 1000000,
            "param_type": "int",
            "description": "Default agent token budget"
          },
          {
            "name": "default_max_turns",
            "current": null,
            "default": 50,
            "min_val": 10,
            "max_val": 200,
            "param_type": "int",
            "description": "Default agent turn limit"
          },
          {
            "name": "default_rate_limit",
            "current": null,
            "default": 60,
            "min_val": 10,
            "max_val": 200,
            "param_type": "int",
            "description": "Tool calls per minute"
          },
          {
            "name": "default_read_only",
            "current": null,
            "default": false,
            "min_val": null,
            "max_val": null,
            "param_type": "bool",
            "description": "Default read-only mode"
          }
        ],
        "fitness_score": 1.0,
        "last_evaluated": "2026-02-19T19:38:02.515748",
        "mutations_applied": 0
      },
      "events.bus": {
        "component": "events.bus",
        "layer": "Episodic Experience",
        "params": [
          {
            "name": "history_limit",
            "current": null,
            "default": 500,
            "min_val": 100,
            "max_val": 5000,
            "param_type": "int",
            "description": "Max events in memory"
          }
        ],
        "fitness_score": 1.0,
        "last_evaluated": "2026-02-19T19:38:02.515760",
        "mutations_applied": 0
      },
      "events.tracing": {
        "component": "events.tracing",
        "layer": "Episodic Experience",
        "params": [
          {
            "name": "max_traces",
            "current": 194,
            "default": 200,
            "min_val": 50,
            "max_val": 1000,
            "param_type": "int",
            "description": "Max traces retained"
          }
        ],
        "fitness_score": 0.5,
        "last_evaluated": "2026-02-19T19:38:02.515768",
        "mutations_applied": 1
      }
    },
    "recent_mutations": [
      {
        "id": "6e4bde913834",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 38,
        "new_value": 72,
        "reason": "LLM: With perfect retrieval hit rates and high graph density, the current 38-hour threshold may be consolidating knowledge too aggressively. Increasing to 72 hours allows more time for knowledge to mature before consolidation, potentially reducing policy violations.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:18:35.234727"
      },
      {
        "id": "cf54eca8a2b0",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 6,
        "new_value": 15,
        "reason": "LLM: The 100% policy violation rate suggests personas may be operating with insufficient exploration time. Increasing researcher max turns from 6 to 15 allows for more thorough investigation and better policy compliance.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:18:35.235034"
      },
      {
        "id": "be26a5c40859",
        "component": "knowledge.loom",
        "param_name": "recall_limit",
        "old_value": 11,
        "new_value": 25,
        "reason": "LLM: With perfect retrieval rates but high policy violations, the current recall limit of 11 may be too restrictive, forcing the system to make decisions with insufficient context. Increasing to 25 should provide better decision-making foundation.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:18:35.235163"
      },
      {
        "id": "9fe1123a52fc",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 72,
        "new_value": 48,
        "reason": "LLM: Reduce from 72 to 48 hours to consolidate knowledge more frequently, which should help reduce policy violations by keeping knowledge more current and organized",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:25:39.300442"
      },
      {
        "id": "6d93460db0b8",
        "component": "knowledge.loom",
        "param_name": "recall_limit",
        "old_value": 25,
        "new_value": 15,
        "reason": "LLM: Reduce from 25 to 15 to limit recall scope and potentially reduce the aggressive behavior causing policy violations while maintaining good retrieval performance",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:25:39.300594"
      },
      {
        "id": "2e96854f575d",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 15,
        "new_value": 10,
        "reason": "LLM: Reduce from 15 to 10 turns to constrain researcher behavior and help address the 100% policy violation rate by limiting interaction depth",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:25:39.300675"
      },
      {
        "id": "aefc6b9635e3",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 48,
        "new_value": 24,
        "reason": "LLM: Reduce consolidation threshold to prevent stale knowledge from causing policy violations - faster consolidation should improve knowledge freshness",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:30:18.018075"
      },
      {
        "id": "17c82b4c70cf",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 10,
        "new_value": 6,
        "reason": "LLM: Limit researcher exploration turns to reduce policy violations while maintaining effectiveness - shorter interaction cycles should improve compliance",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:30:18.018215"
      },
      {
        "id": "1a09d6cd4376",
        "component": "intent.personas",
        "param_name": "orchestrator_budget",
        "old_value": 150000,
        "new_value": 100000,
        "reason": "LLM: Reduce orchestrator budget to constrain resource usage and potentially reduce policy violations from over-aggressive coordination",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:30:18.018289"
      },
      {
        "id": "cb589f5ce6b9",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 24,
        "new_value": 6,
        "reason": "Fitness 0.50 < 0.6, adjusting older_than_hours",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:31:03.363659"
      },
      {
        "id": "f476120bc117",
        "component": "knowledge.consolidator",
        "param_name": "max_concurrent_writes",
        "old_value": 6,
        "new_value": 12,
        "reason": "LLM: High activity levels (1.00) suggest the system needs more write throughput. Doubling from 6 to 12 concurrent writes will better handle the load and reduce bottlenecks that may contribute to policy violations.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:35:18.555208"
      },
      {
        "id": "bd4122e7f25e",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 6,
        "new_value": 12,
        "reason": "LLM: 100% policy violation rate suggests personas need more turns to properly complete tasks within policy bounds. Doubling researcher turns from 6 to 12 allows more thorough exploration while staying within constraints.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:35:18.555346"
      },
      {
        "id": "92a1c4e841a5",
        "component": "intent.personas",
        "param_name": "researcher_budget",
        "old_value": 80000,
        "new_value": 200000,
        "reason": "LLM: Current budget of 80k is too restrictive given 100% policy violation rate - agents may be bypassing policies due to resource constraints",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:41:53.763845"
      },
      {
        "id": "8f38164f5cca",
        "component": "intent.personas",
        "param_name": "coder_budget",
        "old_value": 85000,
        "new_value": 180000,
        "reason": "LLM: Increase from 85k to reduce pressure that leads to policy violations while maintaining efficiency",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:41:53.763889"
      },
      {
        "id": "1107c229b9e7",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 12,
        "new_value": 25,
        "reason": "LLM: Low turn limit of 12 may force rushed decisions leading to policy violations - allow more deliberate processing",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:41:53.763919"
      },
      {
        "id": "676d43ffa549",
        "component": "intent.personas",
        "param_name": "researcher_budget",
        "old_value": 200000,
        "new_value": 286862,
        "reason": "Fitness 0.50 < 0.6, adjusting researcher_budget",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:42:29.746759"
      },
      {
        "id": "a9bef79e3dc7",
        "component": "intent.personas",
        "param_name": "coder_budget",
        "old_value": 180000,
        "new_value": 350000,
        "reason": "LLM: Policy violation rate of 1.00 suggests coding operations may be failing due to insufficient budget (180k vs researcher's 286k). Increasing to 350k should reduce violations.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:45:53.648961"
      },
      {
        "id": "29e57e98d635",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 6,
        "new_value": 24,
        "reason": "LLM: With perfect semantic retrieval and high graph density, consolidating knowledge every 6 hours may be too aggressive and causing policy violations. Extending to 24 hours reduces consolidation frequency.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:45:53.649017"
      },
      {
        "id": "1e968d186218",
        "component": "intent.personas",
        "param_name": "coder_max_turns",
        "old_value": 12,
        "new_value": 25,
        "reason": "LLM: Coder max turns (12) is much lower than researcher (25). Policy violations may stem from coders hitting turn limits before completing tasks. Matching researcher turns should help.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:45:53.649052"
      },
      {
        "id": "b70e00feaba0",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 24,
        "new_value": 42,
        "reason": "Fitness 0.50 < 0.6, adjusting older_than_hours",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:46:30.334397"
      },
      {
        "id": "84dc8840134b",
        "component": "intent.personas",
        "param_name": "orchestrator_budget",
        "old_value": 100000,
        "new_value": 200000,
        "reason": "LLM: Double orchestrator budget to better manage policy violations and coordinate between researcher/coder personas",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:50:27.046966"
      },
      {
        "id": "349a5ee85ee9",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 25,
        "new_value": 15,
        "reason": "LLM: Reduce researcher turns to prevent over-exploration that may contribute to policy violations",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:50:27.047031"
      },
      {
        "id": "8ec105839d8f",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 42,
        "new_value": 24,
        "reason": "LLM: Increase consolidation frequency to better organize knowledge and potentially reduce policy conflicts",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:50:27.047075"
      },
      {
        "id": "a2c0ad99a198",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 24,
        "new_value": 11,
        "reason": "Fitness 0.50 < 0.6, adjusting older_than_hours",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:51:07.515560"
      },
      {
        "id": "2196ca1f1c96",
        "component": "intent.personas",
        "param_name": "orchestrator_budget",
        "old_value": 200000,
        "new_value": 254268,
        "reason": "Fitness 0.50 < 0.6, adjusting orchestrator_budget",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:51:07.515600"
      },
      {
        "id": "f6ac56ebba6a",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 15,
        "new_value": 45,
        "reason": "LLM: Increase from 15 to 45 to allow more thorough task completion and reduce policy violations caused by premature termination",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:54:35.475465"
      },
      {
        "id": "bda6ae7c29d2",
        "component": "intent.personas",
        "param_name": "coder_max_turns",
        "old_value": 25,
        "new_value": 60,
        "reason": "LLM: Increase from 25 to 60 to better utilize the high budget allocation and prevent rushed implementations that violate policies",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:54:35.475501"
      },
      {
        "id": "35781097e770",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 11,
        "new_value": 24,
        "reason": "LLM: Increase consolidation frequency from 11 to 24 hours to better support the high activity levels shown in audit signals",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:54:35.475524"
      },
      {
        "id": "c7820f69a90e",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 24,
        "new_value": 6,
        "reason": "Fitness 0.50 < 0.6, adjusting older_than_hours",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:55:11.824638"
      },
      {
        "id": "4dd498f6eb59",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 6,
        "new_value": 12,
        "reason": "LLM: Double consolidation frequency to reduce memory pressure and improve coordination between components, which may help reduce policy violations",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:58:51.148046"
      },
      {
        "id": "bd5ef9013617",
        "component": "knowledge.loom",
        "param_name": "recall_limit",
        "old_value": 15,
        "new_value": 25,
        "reason": "LLM: Increase recall capacity to provide richer context for decision-making, potentially reducing policy violations through better informed actions",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:58:51.148152"
      },
      {
        "id": "77c375d6ce4a",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 45,
        "new_value": 35,
        "reason": "LLM: Reduce researcher turn limit to prevent excessive exploration that may be contributing to policy violations while maintaining adequate research capability",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T08:58:51.148246"
      },
      {
        "id": "79c841c0ab19",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 12,
        "new_value": 8,
        "reason": "LLM: Reduce from 12 to 8 hours to consolidate knowledge more frequently, helping reduce policy violations by ensuring fresher, more relevant knowledge is available for decision-making",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:02:58.480817"
      },
      {
        "id": "db0c74840965",
        "component": "knowledge.consolidator",
        "param_name": "max_concurrent_writes",
        "old_value": 12,
        "new_value": 8,
        "reason": "LLM: Reduce from 12 to 8 to limit system load and prevent resource contention that may be contributing to the high violation rate and activity overload",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:02:58.480913"
      },
      {
        "id": "3ab23bfb97c1",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 35,
        "new_value": 25,
        "reason": "LLM: Reduce from 35 to 25 turns to constrain the researcher persona's exploration depth, reducing system load and potentially improving decision quality under the current high-activity conditions",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:02:58.480973"
      },
      {
        "id": "3291021da73a",
        "component": "intent.personas",
        "param_name": "orchestrator_budget",
        "old_value": 254268,
        "new_value": 450000,
        "reason": "LLM: 100% policy violation rate suggests the orchestrator needs more resources to properly coordinate and enforce policies across the system",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:07:16.396431"
      },
      {
        "id": "13a453cc6e0b",
        "component": "intent.personas",
        "param_name": "researcher_budget",
        "old_value": 286862,
        "new_value": 400000,
        "reason": "LLM: With perfect retrieval hit rates and high graph density, the researcher should have more budget to leverage this rich knowledge base effectively",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:07:16.396525"
      },
      {
        "id": "4c1ea6b67adf",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 8,
        "new_value": 24,
        "reason": "LLM: High activity levels and perfect utilization suggest knowledge is being generated rapidly - consolidate more frequently to maintain system performance",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:07:16.396583"
      },
      {
        "id": "7343c99faf2a",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 24,
        "new_value": 12,
        "reason": "Fitness 0.50 < 0.6, adjusting older_than_hours",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:07:52.622099"
      },
      {
        "id": "b7faac40d450",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 12,
        "new_value": 24,
        "reason": "LLM: With perfect retrieval hit rates and high graph density, the current 12-hour consolidation window may be too aggressive, potentially consolidating knowledge before policy violations can be properly detected and resolved. Doubling to 24 hours allows more time for policy validation.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:12:14.466715"
      },
      {
        "id": "b070c1bdc39a",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 25,
        "new_value": 15,
        "reason": "LLM: The 100% policy violation rate suggests personas are operating without sufficient constraints. Reducing researcher turns from 25 to 15 will force more focused, compliant behavior while still allowing meaningful research within the substantial 400k budget.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:12:14.466810"
      },
      {
        "id": "e8d87cfaa358",
        "component": "intent.personas",
        "param_name": "coder_max_turns",
        "old_value": 60,
        "new_value": 40,
        "reason": "LLM: Similarly reducing coder turns from 60 to 40 to enforce more disciplined coding practices and reduce policy violations, while maintaining sufficient iterations for quality code development within the 350k budget allocation.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:12:14.466868"
      },
      {
        "id": "468d58699f2d",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 24,
        "new_value": 32,
        "reason": "Fitness 0.50 < 0.6, adjusting older_than_hours",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:12:51.218676"
      },
      {
        "id": "c5aafc5361a4",
        "component": "intent.personas",
        "param_name": "coder_max_turns",
        "old_value": 40,
        "new_value": 41,
        "reason": "Fitness 0.50 < 0.6, adjusting coder_max_turns",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:12:51.218717"
      },
      {
        "id": "2ff49aeabf41",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 32,
        "new_value": 12,
        "reason": "LLM: With perfect retrieval hit rates and high graph density, knowledge is being accessed frequently. Reducing consolidation threshold from 32 to 12 hours will consolidate active knowledge faster, potentially reducing policy violations by ensuring fresher, more relevant knowledge clusters.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:17:11.110551"
      },
      {
        "id": "8990101685aa",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 15,
        "new_value": 25,
        "reason": "LLM: 100% policy violation rate suggests personas may be hitting limits or constraints. Increasing researcher turns from 15 to 25 allows more thorough investigation and policy compliance checking before taking actions.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:17:11.110603"
      },
      {
        "id": "fcbfcafe6b70",
        "component": "knowledge.loom",
        "param_name": "recall_limit",
        "old_value": 25,
        "new_value": 35,
        "reason": "LLM: High activity levels and topic diversity suggest complex scenarios requiring more context. Increasing recall limit from 25 to 35 provides richer context for decision-making, potentially reducing policy violations through better informed actions.",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-18T09:17:11.110632"
      },
      {
        "id": "22814579e7a5",
        "component": "knowledge.consolidator",
        "param_name": "older_than_hours",
        "old_value": 12,
        "new_value": 24,
        "reason": "LLM: Double the consolidation threshold to reduce frequency of knowledge consolidation operations, which may be contributing to policy violations by creating too much concurrent activity",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-19T19:38:09.215212"
      },
      {
        "id": "9087d61d4694",
        "component": "knowledge.loom",
        "param_name": "recall_limit",
        "old_value": 35,
        "new_value": 25,
        "reason": "LLM: Reduce recall limit to decrease memory pressure and processing overhead, potentially reducing policy violations while maintaining good retrieval performance",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-19T19:38:09.215249"
      },
      {
        "id": "852e67913279",
        "component": "intent.personas",
        "param_name": "researcher_max_turns",
        "old_value": 25,
        "new_value": 15,
        "reason": "LLM: Reduce researcher turn limit to constrain resource usage and prevent excessive exploration that may be causing policy violations, while keeping budget allocation intact",
        "fitness_before": 0.5,
        "fitness_after": null,
        "applied": true,
        "timestamp": "2026-02-19T19:38:09.215268"
      }
    ],
    "timestamp": "2026-02-19T19:38:10.099373"
  },
  "meta_cycles_completed": 202,
  "design_archive": {
    "max_size": 50,
    "temperature": 0.3,
    "entries": [
      {
        "id": "23c39b4c43c6",
        "strategy_name": "Weighted Graph Traverser",
        "module": "knowledge.graph",
        "code_hash": "5591d98ed2221fe3",
        "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] = round(score, 4)\n            for dst, rel, w in self.edges.get(node, []):\n                queue.append((dst, score * w * decay, depth + 1))\n        return visited\n\ng = WeightedGraph()\ng.add('agent', 'uses', 'memory', 0.9)\ng.add('memory', 'contains', 'facts', 0.8)\ng.add('agent', 'has', 'policy', 0.7)\ng.add('facts', 'derived_from', 'papers', 0.6)\nresult = g.traverse('agent', max_depth=3)\nassert 'memory' in result and 'facts' in result\nassert result['agent'] == 1.0\nassert result['memory'] < 1.0\nprint(f'Graph traversal: {result}')\nprint('PASS: Weighted graph traverser validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.15006v1",
        "created_at": "2026-02-17T21:25:58.247616"
      },
      {
        "id": "fc04ce7d8615",
        "strategy_name": "Weighted Graph Traverser",
        "module": "knowledge.graph",
        "code_hash": "5591d98ed2221fe3",
        "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] = round(score, 4)\n            for dst, rel, w in self.edges.get(node, []):\n                queue.append((dst, score * w * decay, depth + 1))\n        return visited\n\ng = WeightedGraph()\ng.add('agent', 'uses', 'memory', 0.9)\ng.add('memory', 'contains', 'facts', 0.8)\ng.add('agent', 'has', 'policy', 0.7)\ng.add('facts', 'derived_from', 'papers', 0.6)\nresult = g.traverse('agent', max_depth=3)\nassert 'memory' in result and 'facts' in result\nassert result['agent'] == 1.0\nassert result['memory'] < 1.0\nprint(f'Graph traversal: {result}')\nprint('PASS: Weighted graph traverser validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.14970v1",
        "created_at": "2026-02-17T21:25:58.247750"
      },
      {
        "id": "9841efb88087",
        "strategy_name": "Softmax Diversity Scorer",
        "module": "knowledge.semantic",
        "code_hash": "cd13aa12d8457ce4",
        "code_snippet": "import math\nimport random\n\ndef softmax_score(values, temperature=0.3):\n    if not values: return []\n    exp_vals = [math.exp(v / max(temperature, 0.01)) for v in values]\n    total = sum(exp_vals)\n    return [v / total for v in exp_vals]\n\nscores = softmax_score([0.9, 0.7, 0.4, 0.2, 0.1])\nassert abs(sum(scores) - 1.0) < 0.001\nprint(f'Softmax scores: {[round(s,3) for s in scores]}')\nprint('PASS: Softmax diversity scorer validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.15021v1",
        "created_at": "2026-02-17T21:28:46.918659"
      },
      {
        "id": "5dd2ab6f4ab8",
        "strategy_name": "Weighted Graph Traverser",
        "module": "knowledge.graph",
        "code_hash": "5591d98ed2221fe3",
        "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] = round(score, 4)\n            for dst, rel, w in self.edges.get(node, []):\n                queue.append((dst, score * w * decay, depth + 1))\n        return visited\n\ng = WeightedGraph()\ng.add('agent', 'uses', 'memory', 0.9)\ng.add('memory', 'contains', 'facts', 0.8)\ng.add('agent', 'has', 'policy', 0.7)\ng.add('facts', 'derived_from', 'papers', 0.6)\nresult = g.traverse('agent', max_depth=3)\nassert 'memory' in result and 'facts' in result\nassert result['agent'] == 1.0\nassert result['memory'] < 1.0\nprint(f'Graph traversal: {result}')\nprint('PASS: Weighted graph traverser validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-17T21:28:46.918739"
      },
      {
        "id": "f2c46d69e55c",
        "strategy_name": "Weighted Graph Traverser",
        "module": "knowledge.graph",
        "code_hash": "5591d98ed2221fe3",
        "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] = round(score, 4)\n            for dst, rel, w in self.edges.get(node, []):\n                queue.append((dst, score * w * decay, depth + 1))\n        return visited\n\ng = WeightedGraph()\ng.add('agent', 'uses', 'memory', 0.9)\ng.add('memory', 'contains', 'facts', 0.8)\ng.add('agent', 'has', 'policy', 0.7)\ng.add('facts', 'derived_from', 'papers', 0.6)\nresult = g.traverse('agent', max_depth=3)\nassert 'memory' in result and 'facts' in result\nassert result['agent'] == 1.0\nassert result['memory'] < 1.0\nprint(f'Graph traversal: {result}')\nprint('PASS: Weighted graph traverser validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T02:18:08.127529"
      },
      {
        "id": "354217f95e79",
        "strategy_name": "Weighted Graph Traverser",
        "module": "knowledge.graph",
        "code_hash": "5591d98ed2221fe3",
        "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] = round(score, 4)\n            for dst, rel, w in self.edges.get(node, []):\n                queue.append((dst, score * w * decay, depth + 1))\n        return visited\n\ng = WeightedGraph()\ng.add('agent', 'uses', 'memory', 0.9)\ng.add('memory', 'contains', 'facts', 0.8)\ng.add('agent', 'has', 'policy', 0.7)\ng.add('facts', 'derived_from', 'papers', 0.6)\nresult = g.traverse('agent', max_depth=3)\nassert 'memory' in result and 'facts' in result\nassert result['agent'] == 1.0\nassert result['memory'] < 1.0\nprint(f'Graph traversal: {result}')\nprint('PASS: Weighted graph traverser validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T02:18:08.127802"
      },
      {
        "id": "10c855caa01d",
        "strategy_name": "Weighted Graph Traverser",
        "module": "knowledge.graph",
        "code_hash": "5591d98ed2221fe3",
        "code_snippet": "from collections import defaultdict\n\nclass WeightedGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n    def traverse(self, start, max_depth=3, decay=0.7):\n        visited = {}\n        queue = [(start, 1.0, 0)]\n        while queue:\n            node, score, depth = queue.pop(0)\n            if node in visited or depth > max_depth:\n                continue\n            visited[node] = round(score, 4)\n            for dst, rel, w in self.edges.get(node, []):\n                queue.append((dst, score * w * decay, depth + 1))\n        return visited\n\ng = WeightedGraph()\ng.add('agent', 'uses', 'memory', 0.9)\ng.add('memory', 'contains', 'facts', 0.8)\ng.add('agent', 'has', 'policy', 0.7)\ng.add('facts', 'derived_from', 'papers', 0.6)\nresult = g.traverse('agent', max_depth=3)\nassert 'memory' in result and 'facts' in result\nassert result['agent'] == 1.0\nassert result['memory'] < 1.0\nprint(f'Graph traversal: {result}')\nprint('PASS: Weighted graph traverser validated')\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 0,
        "parent_id": "",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T03:00:22.964747"
      },
      {
        "id": "a41492be3cc6",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "99af9536439e4589",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n        self.relation_weights[rel] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score, 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * w * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return {'scores': visited, 'paths': paths}\n    \n    def find_connections(self, node1, node2, max_depth=4):\n        \"\"\"Find all paths between two nodes\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue:\n            current, path, score, depth = queue.popleft()\n            \n            if current == node2:\n                paths.append({'path': path, 'score': round(score, 4)})\n                continue\n            \n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(current, []):\n                if dst not in path:\n                    new_score = score * w * (0.8 ** depth)\n                    queue.append((dst, path + [dst], new_score, depth + 1))\n        \n        return sorted(paths, key=lambda x: x['score'], reverse=True)\n    \n    def get_neighborhood(self, node, radius=2):\n        \"\"\"Get bidirectional neighborhood of a node\"\"\"\n        neighborhood = set([node])\n        current_layer = {node}\n        \n        for _ in range(radius):\n            next_layer = set()\n            for n in current_layer:\n                # Forward edges\n                for dst, _, _ in self.edges.get(n, []):\n                    next_layer.add(dst)\n                # Backward edges\n                for src, _, _ in self.reverse_edges.get(n, []):\n                    next_layer.add(src)\n            \n            neighborhood.update(next_layer)\n            current_layer = next_layer - neighborhood\n            \n        return neighborhood\n\n# Test",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "f2c46d69e55c",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T07:22:06.870503"
      },
      {
        "id": "c829999d03f9",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "0894ba48f37c7a1c",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_importance(self, node, importance):\n        self.node_weights[node] = importance\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            # Apply node importance weighting\n            final_score = score * self.node_weights[node]\n            visited[node] = {\n                'score': round(final_score, 4),\n                'depth': depth,\n                'path': path.copy()\n            }\n            \n            # Explore neighbors\n            for dst, rel, edge_weight in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                new_score = final_score * edge_weight * decay\n                new_path = path + [(node, rel, dst)]\n                queue.append((dst, new_score, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], 0)])\n        \n        while queue:\n            node, path, depth = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if node == end and len(path) > 1:\n                paths.append(path)\n                continue\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst not in path:  # Avoid cycles\n                    queue.append((dst, path + [dst], depth + 1))\n        \n        return paths\n    \n    def get_related_concepts(self, concept, relation_types=None, bidirectional=True):\n        related = set()\n        \n        # Forward relations\n        for dst, rel, weight in self.edges.get(concept, []):\n            if not relation_types or rel in relation_types:\n                related.add((dst, rel, weight, 'forward'))\n        \n        # Backward relations\n        if bidirectional:\n            for src, rel, weight in self.reverse_edges.get(concept, []):\n                if not relation_types or rel in relation_types:\n                    rel",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "354217f95e79",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T07:22:25.672796"
      },
      {
        "id": "d08293a5678a",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "d2b85ba7cfc5b484",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        \n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_importance(self, node, importance):\n        self.node_weights[node] = importance\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def compute_pagerank(self, damping=0.85, iterations=20):\n        nodes = set(self.edges.keys()) | set(self.reverse_edges.keys())\n        if not nodes:\n            return {}\n            \n        pagerank = {node: 1.0 / len(nodes) for node in nodes}\n        \n        for _ in range(iterations):\n            new_pagerank = {}\n            for node in nodes:\n                rank = (1 - damping) / len(nodes)\n                for src, _, weight in self.reverse_edges.get(node, []):\n                    out_degree = len(self.edges.get(src, []))\n                    if out_degree > 0:\n                        rank += damping * (pagerank[src] * weight) / out_degree\n                new_pagerank[node] = rank\n            pagerank = new_pagerank\n        \n        return pagerank\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, use_pagerank=True):\n        if use_pagerank:\n            pagerank_scores = self.compute_pagerank()\n        else:\n            pagerank_scores = {}\n            \n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n            \n            # Enhanced scoring with PageRank and relation weights\n            node_importance = self.node_weights[node]\n            if use_pagerank and node in pagerank_scores:\n                node_importance *= pagerank_scores[node] * len(pagerank_scores)\n                \n            final_score = score * node_importance\n            visited[node] = {\n                'score': round(final_score, 4),\n                'depth': depth,\n                'path': path.copy(),\n                'metadata': self.node_metadata.get(node, {})\n   ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "c829999d03f9",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T07:26:16.188219"
      },
      {
        "id": "312ad282571c",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "f88db6fd2d57831c",
        "code_snippet": "from collections import defaultdict, deque\nimport json\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_metadata = defaultdict(dict)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if metadata:\n            self.node_metadata[src].update(metadata)\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score, 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                new_score = score * w * (decay ** depth)\n                queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return {'nodes': visited, 'paths': paths}\n    \n    def find_connections(self, node1, node2, max_depth=4):\n        \"\"\"Find all paths between two nodes\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue:\n            current, path, score, depth = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if current == node2:\n                paths.append({'path': path, 'score': round(score, 4)})\n                continue\n            \n            for dst, rel, w in self.edges.get(current, []):\n                if dst not in path:  # Avoid cycles\n                    queue.append((dst, path + [dst], score * w, depth + 1))\n        \n        return sorted(paths, key=lambda x: x['score'], reverse=True)\n    \n    def get_neighbors(self, node, relation_filter=None, bidirectional=True):\n        \"\"\"Get neighboring nodes with optional relation filtering\"\"\"\n        neighbors = {}\n        \n        # Outgoing edges\n        for dst, rel, w in self.edges.get(node, []):\n            if not relation_filter or rel in relation_filter:\n                neighbors[dst] = {'relation': rel, 'weight': w, 'direction': 'out'}\n        \n        # Incoming edges if bidirectional\n        if bidirectional:\n            for src, rel, w in self.reverse_edges.get(node, []):\n                if not relation_filter or rel in relation_filter:\n                    neighbors[src] = {'relation': rel, 'weight': w, 'direction': 'in'}\n        \n        return neighbors\n    \n    def compute_centrality(self):\n        \"\"\"Compute node centrality based on weighted connections\"\"\"\n        centrality = defaultdict(float)\n        \n        for node in set(list(self.edges.keys()) + list(",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "f2c46d69e55c",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T07:29:43.232512"
      },
      {
        "id": "bf1b7f1a9d88",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "cd34a530e7dc50f4",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * w * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_connections(self, node1, node2, max_depth=4):\n        \"\"\"Find all paths between two nodes\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue:\n            current, path, score, depth = queue.popleft()\n            \n            if current == node2:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(current, []):\n                if dst not in path:\n                    queue.append((dst, path + [dst], score * w, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_neighborhood(self, node, radius=2):\n        \"\"\"Get all nodes within radius distance\"\"\"\n        neighborhood = set([node])\n        current_layer = {node}\n        \n        for _ in range(radius):\n            next_layer = set()\n            for n in current_layer:\n                for dst, _, _ in self.edges.get(n, []):\n                    if dst not in neighborhood:\n                        next_layer.add(dst)\n                        neighborhood.add(dst)\n            current_layer = next_layer\n            \n        return neighborhood\n    \n    def compute_centrality(self):\n        \"\"\"Compute betweenness centrality for nodes\"\"\"\n        centrality = defaultdict(float)\n        nodes = se",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "10c855caa01d",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T07:30:07.365902"
      },
      {
        "id": "39edd13dc002",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "5bcc14af4242bc8d",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                if dst not in path:  # Prevent cycles\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_connections(self, node1, node2, max_depth=4, top_k=5):\n        \"\"\"Find top-k paths between two nodes\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue:\n            current, path, score, depth = queue.popleft()\n            \n            if current == node2:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(current, []):\n                if dst not in path:\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight * (0.8 ** depth)\n                    queue.append((dst, path + [dst], new_score, depth + 1))\n        \n        return sorted(paths, key=lambd",
        "fitness_scores": [
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "bf1b7f1a9d88",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T07:34:14.272212"
      },
      {
        "id": "942d7dea62cb",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "9f69ddd8b04238ca",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, relation_filter=None, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if depth > max_depth or score < min_score:\n                continue\n                \n            if node not in visited or visited[node]['score'] < score:\n                visited[node] = {\n                    'score': round(score * self.node_weights[node], 4),\n                    'depth': depth,\n                    'path': path.copy()\n                }\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst in path:  # Avoid cycles\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                new_score = score * weight * decay\n                new_path = path + [dst]\n                queue.append((dst, new_score, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue:\n            node, path, score, depth = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if node == end:\n                paths.append({\n                    'path': path,\n                    'score': round(score, 4),\n                    'relations': self._get_path_relations(path)\n                })\n                continue\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst not in path:\n                    queue.append((dst, path + [dst], score * weight, depth + 1))\n        \n        return sorted(paths, key=lambda x: x['score'], reverse=True)\n    \n    def _get_path_relations(self, path):\n        relations = []\n        for i in range(len(path) - 1):\n            src, dst = path[i], path[i + 1]\n            for d, rel, _ in self.edges.get(src, []):\n                if d == dst:\n                    relations.append(rel)\n                    break\n        return relations\n    \n    def get_neighbors(self",
        "fitness_scores": [
          1.0,
          1.0,
          0.6,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "354217f95e79",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T07:34:33.613734"
      },
      {
        "id": "7f7481b7aa82",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "5e29454e8e7fc634",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.edge_metadata = {}\n    \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None):\n        edge_id = (src, rel, dst)\n        self.edges[src].append((dst, rel, weight, edge_id))\n        self.reverse_edges[dst].append((src, rel, weight, edge_id))\n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n        self.edge_metadata[edge_id] = {'weight': weight, 'relation': rel}\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = {\n                'score': round(score, 4),\n                'depth': depth,\n                'path': path.copy(),\n                'type': self.node_types.get(node, 'unknown')\n            }\n            \n            for dst, rel, weight, edge_id in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * weight * (decay ** depth)\n                    new_path = path + [node]\n                    queue.append((dst, new_score, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue:\n            node, path, score, depth = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if node == end:\n                paths.append({\n                    'path': path,\n                    'score': round(score, 4),\n                    'length': len(path) - 1\n                })\n                continue\n            \n            for dst, rel, weight, _ in self.edges.get(node, []):\n                if dst not in path:\n                    new_path = path + [dst]\n                    new_score = score * weight\n                    queue.append((dst, new_path, new_score, depth + 1))\n        \n        return sorted(paths, key=lambda x: x['score'], reverse=True)\n    \n    def get_neighbors(self, node, direction='out'):\n        if direction == 'out':\n            return [(dst, rel, weight) for dst, rel, weight, _ in self.edges.get(node, [])]\n        elif direction == 'in':\n            return [(src, rel, weight) for src, rel, weight, _ in self.reverse_edges.get(node, [])]\n        else:\n            out_edges = [(dst, rel, weight) for dst, rel, weight, _ in self.edges.get(node, [])]\n            in_edges = [(src, rel, weight) for src, rel, weight, _ in self.",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "10c855caa01d",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T07:38:44.146871"
      },
      {
        "id": "b232c0ab30a4",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "87f139d494330e6d",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.node_attributes = defaultdict(dict)\n        self.relation_types = set()\n        self.centrality_cache = {}\n        \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None, **attributes):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n        self.relation_weights[rel] = weight\n        self.relation_types.add(rel)\n        \n        # Store additional attributes\n        if attributes:\n            self.node_attributes[src].update(attributes)\n        \n        # Clear cache when graph changes\n        self.centrality_cache.clear()\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, filter_types=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n            \n            # Type filtering\n            if filter_types and self.node_types.get(node) not in filter_types:\n                continue\n                \n            visited[node] = round(score, 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * w * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return {'scores': visited, 'paths': paths}\n    \n    def find_connections(self, node1, node2, max_depth=4, relation_filter=None):\n        \"\"\"Find all paths between two nodes with optional relation filtering\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue:\n            current, path, score, depth = queue.popleft()\n            \n            if current == node2:\n                paths.append({'path': path, 'score': round(score, 4), 'depth': depth})\n                continue\n            \n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, weight in self.edges.get(current, []):\n                if dst not in path:  # Avoid cycles\n                    if relation_filter is None or rel in relation_filter:\n                        new_score = score * weight * (0.8 ** depth)\n                        queue.append((dst, path + [dst], new_score, depth + 1))\n        \n        return sorted(paths, ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "a41492be3cc6",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T07:39:04.371556"
      },
      {
        "id": "3cb795886574",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "d25d244ff9758504",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\nimport re\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_edges = defaultdict(list)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, timestamp=None, attributes=None):\n        edge_data = {'weight': weight, 'timestamp': timestamp, 'attributes': attributes or {}}\n        self.edges[src].append((dst, rel, edge_data))\n        self.reverse_edges[dst].append((src, rel, edge_data))\n        self.relation_types.add(rel)\n        \n        if timestamp:\n            self.temporal_edges[timestamp].append((src, rel, dst, edge_data))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, edge_data))\n            self.reverse_edges[src].append((dst, rel, edge_data))\n    \n    def set_node_importance(self, node, importance):\n        self.node_weights[node] = importance\n    \n    def set_node_attributes(self, node, **attributes):\n        self.node_attributes[node].update(attributes)\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, attribute_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n            \n            # Apply node importance and attribute filtering\n            if attribute_filter and not self._matches_attributes(node, attribute_filter):\n                continue\n                \n            final_score = score * self.node_weights[node]\n            visited[node] = {\n                'score': round(final_score, 4),\n                'depth': depth,\n                'path': path.copy(),\n                'attributes': self.node_attributes[node]\n            }\n            \n            # Explore neighbors with enhanced scoring\n            for dst, rel, edge_data in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                \n                edge_weight = edge_data['weight'] if isinstance(edge_data, dict) else edge_data\n                relation_boost = self.relation_weights[rel]\n                new_score = final_score * edge_weight * relation_boost * decay\n                new_path = path + [(node, rel, dst)]\n                queue.append((dst, new_score, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=4, max_paths=10):\n        paths = []\n        queue =",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "c829999d03f9",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T07:43:34.856949"
      },
      {
        "id": "6e67fc4f4dd6",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "c9f802626917da2f",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        if bidirectional:\n            self.edges[dst].append((src, f\"inv_{rel}\", weight))\n            self.reverse_edges[src].append((dst, f\"inv_{rel}\", weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            current_score = score * self.node_weights[node]\n            visited[node] = round(current_score, 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = current_score * weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_connections(self, node1, node2, max_depth=4):\n        \"\"\"Find all paths between two nodes\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue:\n            current, path, score, depth = queue.popleft()\n            \n            if current == node2:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, weight in self.edges.get(current, []):\n                if dst not in path:\n                    new_path = path + [dst]\n                    new_score = score * weight * 0.9\n                    queue.append((dst, new_path, new_score, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_neighborhood(self, node, radius=2):\n        \"\"\"Get all nodes within radius steps\"\"\"\n        neighborhood = set([node])\n        current_layer = {node}\n        \n        for _ in range(radius):\n            next_layer = set()\n            for n in current_layer:\n                for dst, _, _ in self.edges.get(n, []):\n                    next_layer.add(dst)\n                for src, _, _ in self.reverse_edges.get(n, []):\n                    next_layer.add(src)\n            neighborhood.update(next_layer)\n            current_layer = next_layer\n            \n        return neighborhoo",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "5dd2ab6f4ab8",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-18T07:43:58.332801"
      },
      {
        "id": "547b3239e3ce",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "a92cefa765a28e3c",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, attributes=None):\n        edge_data = {\n            'dst': dst, \n            'rel': rel, \n            'weight': weight,\n            'attributes': attributes or {}\n        }\n        self.edges[src].append(edge_data)\n        self.reverse_edges[dst].append({\n            'dst': src, \n            'rel': rel, \n            'weight': weight,\n            'attributes': attributes or {}\n        })\n        \n        if bidirectional:\n            inv_rel = f\"inv_{rel}\"\n            inv_edge = {\n                'dst': src, \n                'rel': inv_rel, \n                'weight': weight,\n                'attributes': attributes or {}\n            }\n            self.edges[dst].append(inv_edge)\n            self.reverse_edges[src].append(inv_edge)\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_node_attributes(self, node, attributes):\n        self.node_attributes[node].update(attributes)\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        relation_counts = defaultdict(int)\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            current_score = score * self.node_weights[node]\n            visited[node] = round(current_score, 4)\n            paths[node] = path + [node]\n            \n            for edge in self.edges.get(node, []):\n                dst, rel = edge['dst'], edge['rel']\n                weight = edge['weight']\n                \n                if relation_filter and rel not in relation_filter:\n                    continue\n                if dst not in path:  # Prevent cycles\n                    rel_weight = self.relation_weights[rel]\n                    new_score = current_score * weight * rel_weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n                    relation_counts[rel] += 1\n        \n        return {\n            'nodes': visited,\n            'paths': paths,\n            'relation_stats': dict(relation_counts)\n        }\n    \n    def find_connections(self, node1, node2, max_depth=4, max_paths=10):\n        \"\"\"Find all paths between two nodes",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "6e67fc4f4dd6",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-18T07:48:02.465728"
      },
      {
        "id": "a5aa86d23996",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "536d86edad5cc45e",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.edge_metadata = {}\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_edges = {}\n        \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None, timestamp=None, **kwargs):\n        edge_id = (src, rel, dst)\n        self.edges[src].append((dst, rel, weight, edge_id))\n        self.reverse_edges[dst].append((src, rel, weight, edge_id))\n        \n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n            \n        self.edge_metadata[edge_id] = {\n            'weight': weight, \n            'relation': rel, \n            'timestamp': timestamp,\n            **kwargs\n        }\n        \n        if timestamp:\n            self.temporal_edges[edge_id] = timestamp\n            \n        # Update relation strength based on frequency\n        self.relation_weights[rel] = min(2.0, self.relation_weights[rel] + 0.1)\n    \n    def set_node_attributes(self, node, **attributes):\n        self.node_attributes[node].update(attributes)\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [], set())])\n        \n        while queue:\n            node, score, depth, path, visited_edges = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = {\n                'score': round(score, 4),\n                'depth': depth,\n                'path': path.copy(),\n                'type': self.node_types.get(node, 'unknown'),\n                'attributes': dict(self.node_attributes.get(node, {}))\n            }\n            \n            for dst, rel, weight, edge_id in self.edges.get(node, []):\n                if edge_id not in visited_edges and dst not in path:\n                    if relation_filter is None or rel in relation_filter:\n                        relation_boost = self.relation_weights[rel]\n                        new_score = score * weight * relation_boost * (decay ** depth)\n                        new_path = path + [node]\n                        new_visited_edges = visited_edges | {edge_id}\n                        queue.append((dst, new_score, depth + 1, new_path, new_visited_edges))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=10):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0, set())])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth, visited_edges = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "7f7481b7aa82",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T07:49:11.775805"
      },
      {
        "id": "35f1fedc1317",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "13b6cd32322ae46c",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * w * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:\n                    queue.append((dst, path + [dst], score * w, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_neighbors(self, node, relation_filter=None):\n        neighbors = []\n        for dst, rel, w in self.edges.get(node, []):\n            if relation_filter is None or rel == relation_filter:\n                neighbors.append((dst, rel, w))\n        return neighbors\n    \n    def compute_centrality(self):\n        centrality = defaultdict(float)\n        all_nodes = set(self.edges.keys()) | set(self.reverse_edges.keys())\n        \n        for node in all_nodes:\n            out_degree = len(self.edges[node])\n            in_degree = len(self.reverse_edges[node])\n            centrality[node] = math.log(1 + out_degree + in_degree)\n        \n        return dict(centrality)\n\n# Enhanced test with more sophisticated knowledge representation\ng = KnowledgeGraph()\ng",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "f2c46d69e55c",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T07:53:24.356464"
      },
      {
        "id": "7f2945a2bbbf",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "c5de9d57d77e9ddd",
        "code_snippet": "def solution(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # dp[i][j] represents the minimum number of palindromic subsequences\n    # needed to partition s[i:j+1]\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single characters are palindromes\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the dp table for all substring lengths\n    for length in range(2, n + 1):  # length of substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 1  # Two same characters form one palindrome\n                else:\n                    dp[i][j] = dp[i+1][j-1]  # Same as inner substring\n            else:\n                # Try all possible splits\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "5dd2ab6f4ab8",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-18T07:53:48.691690"
      },
      {
        "id": "798abdfe2422",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "4bc10b401f1748be",
        "code_snippet": "from collections import defaultdict, deque\nimport json\nimport math\nimport heapq\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_metadata = defaultdict(dict)\n        self.relation_types = set()\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if metadata:\n            self.node_metadata[src].update(metadata)\n    \n    def set_node_weight(self, node, weight):\n        \"\"\"Set importance weight for a node\"\"\"\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        \"\"\"Set importance weight for a relation type\"\"\"\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, bidirectional=False):\n        visited = {}\n        # Use priority queue for best-first traversal\n        heap = [(-1.0, 0, start, [])]\n        paths = {}\n        \n        while heap:\n            neg_score, depth, node, path = heapq.heappop(heap)\n            score = -neg_score\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score, 4)\n            paths[node] = path + [node]\n            \n            # Forward traversal\n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in visited:\n                    new_score = score * w * (decay ** depth) * self.node_weights[dst] * self.relation_weights[rel]\n                    heapq.heappush(heap, (-new_score, depth + 1, dst, path + [node]))\n            \n            # Optional bidirectional traversal\n            if bidirectional:\n                for src, rel, w in self.reverse_edges.get(node, []):\n                    if src not in visited:\n                        new_score = score * w * (decay ** depth) * self.node_weights[src] * self.relation_weights[rel]\n                        heapq.heappush(heap, (-new_score, depth + 1, src, path + [node]))\n        \n        return {'nodes': visited, 'paths': paths}\n    \n    def find_connections(self, node1, node2, max_depth=4, max_paths=10):\n        \"\"\"Find shortest and highest-scoring paths between two nodes\"\"\"\n        paths = []\n        # Use priority queue to find best paths first\n        heap = [(-1.0, 0, node1, [node1])]\n        visited_states = set()\n        \n        while heap and len(paths) < max_paths:\n            neg_score, depth, current, path = heapq.heappop(heap)\n            score = -neg_score\n            \n            state = (current, tuple(path))\n            if state in visited_states or depth > max_depth:\n                continue\n            visited_states.add(state)",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "312ad282571c",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T07:58:50.627746"
      },
      {
        "id": "f0879b85a3bd",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "5791b9803769bf1d",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst in path:  # Prevent cycles\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                new_score = score * w * (decay ** depth)\n                queue.append((dst, new_score, depth + 1, path + [dst]))\n        \n        return dict(sorted(visited.items(), key=lambda x: x[1], reverse=True))\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=5):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:\n                    queue.append((dst, path + [dst], score * w, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_neighbors(self, node, relation_type=None, direction='outgoing'):\n        edges_dict = self.edges if direction == 'outgoing' else self.reverse_edges\n        neighbors = []\n        \n        for dst, rel, weight in edges_dict.get(node, []):\n            if relation_type is None or rel == relation_type:\n                neighbors.append((dst, rel, weight))\n        \n        return neighbors\n    \n    def cluster_coefficient(self, node):\n        neighbors = [dst for dst, _, _ in self.edges.get(node, [])]\n        if len(neighbors) < 2:\n            return 0.0\n        ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "354217f95e79",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T07:59:09.685550"
      },
      {
        "id": "d8a64f8bca75",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "dc2c285fe9931225",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, attributes=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        \n        if attributes:\n            self.node_attributes[src].update(attributes.get('src', {}))\n            self.node_attributes[dst].update(attributes.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst in path:\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                relation_boost = self.relation_weights[rel]\n                new_score = score * w * relation_boost * (decay ** depth)\n                queue.append((dst, new_score, depth + 1, path + [dst]))\n        \n        return dict(sorted(visited.items(), key=lambda x: x[1], reverse=True))\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=5):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append({'path': path, 'score': round(score, 4), 'length': len(path) - 1})\n                continue\n                \n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                if dst in path:\n                    continue\n                new_score = score * w * self.relation_weights[rel]\n                queue.append((dst, path + [dst], new_score, depth + 1))\n        \n        re",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "f0879b85a3bd",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T08:03:07.867983"
      },
      {
        "id": "1f2b467e2cfc",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2_gen3",
        "module": "knowledge.graph",
        "code_hash": "9cc6c5f87053e383",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\nimport heapq\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.edge_metadata = {}\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_edges = {}\n        self.node_centrality = defaultdict(float)\n        self.relation_patterns = defaultdict(int)\n        self.semantic_clusters = {}\n        \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None, timestamp=None, **kwargs):\n        edge_id = (src, rel, dst)\n        self.edges[src].append((dst, rel, weight, edge_id))\n        self.reverse_edges[dst].append((src, rel, weight, edge_id))\n        \n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n            \n        self.edge_metadata[edge_id] = {\n            'weight': weight, \n            'relation': rel, \n            'timestamp': timestamp,\n            'confidence': kwargs.get('confidence', 1.0),\n            **kwargs\n        }\n        \n        if timestamp:\n            self.temporal_edges[edge_id] = timestamp\n            \n        # Enhanced relation learning with pattern recognition\n        self.relation_weights[rel] = min(2.0, self.relation_weights[rel] + 0.1)\n        self.relation_patterns[(src_type or 'unknown', rel, dst_type or 'unknown')] += 1\n        \n        # Update centrality scores\n        self._update_centrality(src, dst, weight)\n    \n    def _update_centrality(self, src, dst, weight):\n        self.node_centrality[src] += weight * 0.1\n        self.node_centrality[dst] += weight * 0.1\n    \n    def set_node_attributes(self, node, **attributes):\n        self.node_attributes[node].update(attributes)\n        \n        # Auto-cluster nodes with similar attributes\n        if 'category' in attributes:\n            category = attributes['category']\n            if category not in self.semantic_clusters:\n                self.semantic_clusters[category] = set()\n            self.semantic_clusters[category].add(node)\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, semantic_boost=True):\n        visited = {}\n        # Use priority queue for better path exploration\n        heap = [(-1.0, 0, start, [], set())]\n        \n        while heap:\n            neg_score, depth, node, path, visited_edges = heapq.heappop(heap)\n            score = -neg_score\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = {\n                'score': round(score, 4),\n                'depth': depth,\n                'path': path.copy(),\n                'type': self.node_types.get(node, 'unknown'),\n                'attributes': dict(self.node_attributes.get(node, {})),\n            ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 3,
        "parent_id": "a5aa86d23996",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T08:04:06.584288"
      },
      {
        "id": "29d216b8ef85",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "c150282516f04689",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_edges = defaultdict(list)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, timestamp=None, attributes=None):\n        edge_data = (dst, rel, weight, timestamp or 0)\n        self.edges[src].append(edge_data)\n        self.reverse_edges[dst].append((src, rel, weight, timestamp or 0))\n        self.relation_types.add(rel)\n        \n        if timestamp:\n            self.temporal_edges[timestamp].append((src, rel, dst, weight))\n        \n        if attributes:\n            self.node_attributes[src].update(attributes.get('src', {}))\n            self.node_attributes[dst].update(attributes.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight, timestamp or 0))\n            self.reverse_edges[src].append((dst, rel, weight, timestamp or 0))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w, timestamp in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                if dst not in path:  # Prevent cycles\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_paths(self, start, end, max_depth=3, relation_sequence=None):\n        paths = []\n        queue = deque([(start, [start], [], 1.0, 0)])\n        \n        while queue:\n            node, path, relations, score, depth = queue.popleft()\n            \n            if node == end:\n                if not relation_sequence or self._matches_sequence(relations, relation_sequence):\n                    paths.append((path, relations, round(score, 4)))\n                continue\n            if depth >= max_depth:\n        ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "35f1fedc1317",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T08:14:15.690994"
      },
      {
        "id": "0a15e4251a6b",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "b5c7279383961401",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, boost_nodes=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        boost_nodes = boost_nodes or set()\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n            \n            node_boost = 1.5 if node in boost_nodes else 1.0\n            final_score = score * self.node_weights[node] * node_boost\n            visited[node] = round(final_score, 4)\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst in path:\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                rel_weight = self.relation_weights[rel]\n                new_score = score * w * rel_weight * (decay ** depth)\n                queue.append((dst, new_score, depth + 1, path + [dst]))\n        \n        return dict(sorted(visited.items(), key=lambda x: x[1], reverse=True))\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=5):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append({\n                    'path': path,\n                    'score': round(score, 4),\n                    'length': len(path) - 1\n                })\n                continue\n            \n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "f0879b85a3bd",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T08:21:22.283845"
      },
      {
        "id": "41da09bc48be",
        "strategy_name": "Softmax Diversity Scorer_gen1",
        "module": "knowledge.semantic",
        "code_hash": "f252b2beb385ccb8",
        "code_snippet": "import math\nimport random\nfrom collections import defaultdict\n\nclass SemanticScorer:\n    def __init__(self, temperature=0.3, diversity_weight=0.2):\n        self.temperature = max(temperature, 0.01)\n        self.diversity_weight = diversity_weight\n        self.history = defaultdict(float)\n    \n    def softmax_score(self, values, labels=None):\n        if not values: return []\n        \n        # Apply temperature scaling\n        exp_vals = [math.exp(v / self.temperature) for v in values]\n        total = sum(exp_vals)\n        base_scores = [v / total for v in exp_vals]\n        \n        # Apply diversity bonus if labels provided\n        if labels and len(labels) == len(values):\n            diversity_bonus = self._calculate_diversity_bonus(labels)\n            adjusted_scores = []\n            for i, score in enumerate(base_scores):\n                bonus = diversity_bonus.get(labels[i], 0)\n                adjusted_scores.append(score * (1 + self.diversity_weight * bonus))\n            \n            # Renormalize\n            total_adjusted = sum(adjusted_scores)\n            return [s / total_adjusted for s in adjusted_scores]\n        \n        return base_scores\n    \n    def _calculate_diversity_bonus(self, labels):\n        bonus = {}\n        for label in set(labels):\n            # Less frequently selected items get higher bonus\n            frequency = self.history[label]\n            bonus[label] = math.exp(-frequency * 0.5)\n        return bonus\n    \n    def update_selection(self, selected_label):\n        self.history[selected_label] += 1\n    \n    def adaptive_temperature(self, entropy_measure):\n        # Adjust temperature based on entropy of recent selections\n        return max(0.1, min(1.0, 0.3 + entropy_measure * 0.4))\n\n# Test the enhanced semantic scorer\nscorer = SemanticScorer()\nvalues = [0.9, 0.7, 0.4, 0.2, 0.1]\nlabels = ['concept_A', 'concept_B', 'concept_C', 'concept_D', 'concept_E']\n\nscores = scorer.softmax_score(values, labels)\nassert abs(sum(scores) - 1.0) < 0.001\n\n# Simulate selection history to test diversity\nscorer.update_selection('concept_A')\nscorer.update_selection('concept_A')\ndiverse_scores = scorer.softmax_score(values, labels)\n\nprint(f'Initial scores: {[round(s,3) for s in scores]}')\nprint(f'Diversity-adjusted: {[round(s,3) for s in diverse_scores]}')\nprint('PASS: Enhanced semantic scorer with diversity and adaptation validated')",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "9841efb88087",
        "source_paper": "2602.15021v1",
        "created_at": "2026-02-18T08:25:10.993221"
      },
      {
        "id": "e816e96d13c3",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "8da26fd962fdd949",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, attributes=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        \n        if attributes:\n            self.node_attributes[src].update(attributes.get('src', {}))\n            self.node_attributes[dst].update(attributes.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, boost_keywords=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        boost_keywords = boost_keywords or []\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n            \n            # Apply keyword boosting\n            node_boost = 1.0\n            if boost_keywords:\n                for keyword in boost_keywords:\n                    if keyword.lower() in str(node).lower():\n                        node_boost *= 1.5\n                        break\n            \n            final_score = score * self.node_weights[node] * node_boost\n            visited[node] = round(final_score, 4)\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst in path:  # Prevent cycles\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                relation_weight = self.relation_weights[rel]\n                new_score = score * w * relation_weight * (decay ** depth)\n                queue.append((dst, new_score, depth + 1, path + [dst]))\n        \n        return dict(sorted(visited.items(), key=lambda x: x[1], reverse=True))\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=5):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append({'path': path, 'score': round(score, 4",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "f0879b85a3bd",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T08:25:30.152588"
      },
      {
        "id": "612312c2d4be",
        "strategy_name": "Cosine Similarity Ranker_gen1",
        "module": "knowledge.semantic",
        "code_hash": "b5a4b78a5ea2587e",
        "code_snippet": "import math\nimport re\nfrom collections import Counter, defaultdict\n\nclass SemanticIndex:\n    def __init__(self):\n        self.docs = {}\n        self.vocab = set()\n        self.idf_cache = {}\n        \n    def add_document(self, doc_id, text):\n        words = self._tokenize(text)\n        self.docs[doc_id] = words\n        self.vocab.update(words)\n        self.idf_cache.clear()\n        \n    def _tokenize(self, text):\n        return re.findall(r'\\b\\w+\\b', text.lower())\n        \n    def _compute_idf(self):\n        if self.idf_cache:\n            return self.idf_cache\n            \n        doc_freq = defaultdict(int)\n        for words in self.docs.values():\n            for word in set(words):\n                doc_freq[word] += 1\n                \n        total_docs = len(self.docs)\n        for word in self.vocab:\n            self.idf_cache[word] = math.log(total_docs / max(doc_freq[word], 1))\n        return self.idf_cache\n        \n    def _tfidf_vector(self, words):\n        tf = Counter(words)\n        idf = self._compute_idf()\n        vector = []\n        for word in sorted(self.vocab):\n            tf_score = tf.get(word, 0) / max(len(words), 1)\n            tfidf_score = tf_score * idf.get(word, 0)\n            vector.append(tfidf_score)\n        return vector\n        \n    def search(self, query, top_k=None):\n        query_words = self._tokenize(query)\n        query_vec = self._tfidf_vector(query_words)\n        \n        results = []\n        for doc_id, doc_words in self.docs.items():\n            doc_vec = self._tfidf_vector(doc_words)\n            similarity = self._cosine_similarity(query_vec, doc_vec)\n            results.append((doc_id, similarity))\n            \n        results.sort(key=lambda x: -x[1])\n        return results[:top_k] if top_k else results\n        \n    def _cosine_similarity(self, a, b):\n        dot = sum(x * y for x, y in zip(a, b))\n        norm_a = math.sqrt(sum(x * x for x in a))\n        norm_b = math.sqrt(sum(x * x for x in b))\n        return dot / (norm_a * norm_b) if norm_a and norm_b else 0.0\n\n# Test the semantic index\nindex = SemanticIndex()\ndocs = {\n    'doc1': 'agent memory retrieval system',\n    'doc2': 'semantic search vectors embedding',\n    'doc3': 'policy engine rules configuration',\n    'doc4': 'agent memory search optimization'\n}\n\nfor doc_id, text in docs.items():\n    index.add_document(doc_id, text)\n\nresults = index.search('agent memory', top_k=3)\nassert len(results) == 3\nassert results[0][1] >= results[1][1] >= results[2][1]\nprint(f'Search results: {[(doc_id, round(score, 3)) for doc_id, score in results]}')\nprint('PASS: Semantic index with TF-IDF validated')",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "51c366ab94fb",
        "source_paper": "2602.15029v1",
        "created_at": "2026-02-18T08:29:14.415242"
      },
      {
        "id": "3bddd8367ed7",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2_gen3",
        "module": "knowledge.graph",
        "code_hash": "7e53428d780ce8c4",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\nimport time\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.edge_metadata = {}\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_edges = {}\n        self.node_importance = defaultdict(float)\n        self.relation_patterns = defaultdict(int)\n        self.cached_paths = {}\n        \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None, timestamp=None, **kwargs):\n        edge_id = (src, rel, dst)\n        self.edges[src].append((dst, rel, weight, edge_id))\n        self.reverse_edges[dst].append((src, rel, weight, edge_id))\n        \n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n            \n        self.edge_metadata[edge_id] = {\n            'weight': weight, \n            'relation': rel, \n            'timestamp': timestamp or time.time(),\n            **kwargs\n        }\n        \n        if timestamp:\n            self.temporal_edges[edge_id] = timestamp\n            \n        # Enhanced relation learning with pattern recognition\n        self.relation_weights[rel] = min(3.0, self.relation_weights[rel] + 0.15)\n        self.relation_patterns[(src_type, rel, dst_type)] += 1\n        \n        # Update node importance using degree centrality\n        self.node_importance[src] += 0.1 * weight\n        self.node_importance[dst] += 0.1 * weight\n        \n        # Clear cached paths when graph changes\n        self.cached_paths.clear()\n    \n    def set_node_attributes(self, node, **attributes):\n        self.node_attributes[node].update(attributes)\n        if 'importance' in attributes:\n            self.node_importance[node] = max(self.node_importance[node], attributes['importance'])\n    \n    def traverse(self, start, max_depth=3, decay=0.8, min_score=0.01, relation_filter=None, temporal_window=None):\n        cache_key = (start, max_depth, decay, min_score, tuple(relation_filter or []), temporal_window)\n        if cache_key in self.cached_paths:\n            return self.cached_paths[cache_key]\n            \n        visited = {}\n        queue = deque([(start, 1.0, 0, [], set())])\n        current_time = time.time()\n        \n        while queue:\n            node, score, depth, path, visited_edges = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            # Enhanced scoring with node importance and temporal decay\n            importance_boost = 1.0 + (self.node_importance[node] * 0.2)\n            adjusted_score = score * importance_boost\n            \n            visited[node] = {\n                'score': round(adjusted_score, 4),\n                'depth': depth,\n                'path': path.copy(),\n            ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 3,
        "parent_id": "a5aa86d23996",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T08:30:03.163996"
      },
      {
        "id": "73f18f8d6498",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "e23dd4a3af8c927d",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.edge_metadata = {}\n        self.node_embeddings = {}\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_data = {}\n        \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None, timestamp=None, metadata=None):\n        edge_id = (src, rel, dst)\n        self.edges[src].append((dst, rel, weight, edge_id))\n        self.reverse_edges[dst].append((src, rel, weight, edge_id))\n        \n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n            \n        self.edge_metadata[edge_id] = {\n            'weight': weight, \n            'relation': rel,\n            'timestamp': timestamp,\n            'metadata': metadata or {}\n        }\n        \n        # Update relation importance\n        self.relation_weights[rel] = max(self.relation_weights[rel], weight)\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [], set())])\n        \n        while queue:\n            node, score, depth, path, visited_nodes = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = {\n                'score': round(score, 4),\n                'depth': depth,\n                'path': path.copy(),\n                'type': self.node_types.get(node, 'unknown'),\n                'incoming_relations': [rel for _, rel, _, _ in self.reverse_edges.get(node, [])],\n                'outgoing_relations': [rel for _, rel, _, _ in self.edges.get(node, [])]\n            }\n            \n            new_visited = visited_nodes | {node}\n            \n            for dst, rel, weight, edge_id in self.edges.get(node, []):\n                if dst not in new_visited:  # Prevent cycles\n                    if relation_filter is None or rel in relation_filter:\n                        relation_boost = self.relation_weights[rel]\n                        new_score = score * weight * relation_boost * (decay ** depth)\n                        new_path = path + [(node, rel, dst)]\n                        queue.append((dst, new_score, depth + 1, new_path, new_visited))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=10):\n        paths = []\n        queue = deque([(start, [start], [], 1.0, 0, {start})])\n        \n        while queue and len(paths) < max_paths:\n            node, path, relations, score, depth, visited = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if node == end:\n                paths.append({\n                    'pat",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "7f7481b7aa82",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T08:35:08.848292"
      },
      {
        "id": "d4e48739bd4d",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "ae47e0d73be16614",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_types = {}\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, src_type=None, dst_type=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        if src_type:\n            self.node_types[src] = src_type\n        if dst_type:\n            self.node_types[dst] = dst_type\n        self.relation_weights[rel] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score, 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * w * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return {'scores': visited, 'paths': paths}\n    \n    def find_connections(self, node1, node2, max_depth=4):\n        \"\"\"Find shortest weighted path between two nodes\"\"\"\n        if node1 == node2:\n            return [node1]\n        \n        queue = deque([(node1, [node1], 1.0)])\n        visited = set()\n        \n        while queue:\n            current, path, weight = queue.popleft()\n            \n            if current in visited:\n                continue\n            visited.add(current)\n            \n            if len(path) > max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(current, []):\n                if dst == node2:\n                    return path + [dst]\n                if dst not in visited and dst not in path:\n                    queue.append((dst, path + [dst], weight * w))\n        \n        return []\n    \n    def get_related_concepts(self, concept, relation_filter=None, bidirectional=True):\n        \"\"\"Get concepts related by specific relation types\"\"\"\n        related = {}\n        \n        # Forward relations\n        for dst, rel, weight in self.edges.get(concept, []):\n            if not relation_filter or rel in relation_filter:\n                related[dst] = {'relation': rel, 'weight': weight, 'direction': 'outbound'}\n        \n        # Reverse relations if bidirectional\n        if bidirectional:\n            for src, rel, weight in self.reverse_edges.get(concept, []):\n                if not relation_filter or rel in relation_filter:\n                    if src not in related:\n  ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "23c39b4c43c6",
        "source_paper": "2602.15006v1",
        "created_at": "2026-02-18T08:45:14.181172"
      },
      {
        "id": "b780891f05cd",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "5fd63efd3a52a07a",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                if dst not in path:  # Prevent cycles\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=10):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight\n                    queue.append((dst, path + [dst], new_score, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_neighbors(s",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "35f1fedc1317",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T08:45:32.599656"
      },
      {
        "id": "c7734a5d6f5d",
        "strategy_name": "Softmax Diversity Scorer_gen1",
        "module": "knowledge.semantic",
        "code_hash": "5b78664b5772af75",
        "code_snippet": "import math\nimport random\nfrom collections import defaultdict\n\nclass SemanticScorer:\n    def __init__(self, temperature=0.3, diversity_weight=0.2):\n        self.temperature = max(temperature, 0.01)\n        self.diversity_weight = diversity_weight\n        self.history = defaultdict(float)\n    \n    def softmax_score(self, values, labels=None):\n        if not values: return []\n        \n        # Apply temperature scaling\n        exp_vals = [math.exp(v / self.temperature) for v in values]\n        total = sum(exp_vals)\n        base_scores = [v / total for v in exp_vals]\n        \n        # Apply diversity penalty if labels provided\n        if labels and self.diversity_weight > 0:\n            diversity_penalties = [self.history.get(label, 0) for label in labels]\n            max_penalty = max(diversity_penalties) if diversity_penalties else 0\n            \n            adjusted_vals = []\n            for i, val in enumerate(values):\n                penalty = diversity_penalties[i] / (max_penalty + 1e-6)\n                adjusted_val = val * (1 - self.diversity_weight * penalty)\n                adjusted_vals.append(adjusted_val)\n            \n            exp_vals = [math.exp(v / self.temperature) for v in adjusted_vals]\n            total = sum(exp_vals)\n            final_scores = [v / total for v in exp_vals]\n            \n            # Update history for selected items\n            for i, label in enumerate(labels):\n                self.history[label] += final_scores[i]\n            \n            return final_scores\n        \n        return base_scores\n    \n    def entropy_score(self, probabilities):\n        \"\"\"Calculate entropy for diversity measurement\"\"\"\n        return -sum(p * math.log2(p + 1e-10) for p in probabilities if p > 0)\n\nscorer = SemanticScorer(temperature=0.4, diversity_weight=0.3)\nvalues = [0.9, 0.7, 0.4, 0.2, 0.1]\nlabels = ['concept_a', 'concept_b', 'concept_c', 'concept_d', 'concept_e']\n\nscores1 = scorer.softmax_score(values, labels)\nscores2 = scorer.softmax_score(values, labels)  # Should show diversity effect\n\nentropy1 = scorer.entropy_score(scores1)\nentropy2 = scorer.entropy_score(scores2)\n\nassert abs(sum(scores1) - 1.0) < 0.001\nassert abs(sum(scores2) - 1.0) < 0.001\nprint(f'Initial scores: {[round(s,3) for s in scores1]}')\nprint(f'Diversity-adjusted: {[round(s,3) for s in scores2]}')\nprint(f'Entropy change: {round(entropy1,3)} -> {round(entropy2,3)}')\nprint('PASS: Semantic diversity scorer with history validated')",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "9841efb88087",
        "source_paper": "2602.15021v1",
        "created_at": "2026-02-18T08:49:14.532548"
      },
      {
        "id": "10604252c687",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2_gen3",
        "module": "knowledge.graph",
        "code_hash": "1f85beb0a42207ec",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\nimport heapq\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.temporal_edges = defaultdict(list)\n        self.node_embeddings = defaultdict(dict)\n        self.inference_cache = {}\n        self.reasoning_chains = defaultdict(list)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, timestamp=None, attributes=None):\n        edge_data = (dst, rel, weight, timestamp or 0)\n        self.edges[src].append(edge_data)\n        self.reverse_edges[dst].append((src, rel, weight, timestamp or 0))\n        self.relation_types.add(rel)\n        \n        if timestamp:\n            self.temporal_edges[timestamp].append((src, rel, dst, weight))\n        \n        if attributes:\n            self.node_attributes[src].update(attributes.get('src', {}))\n            self.node_attributes[dst].update(attributes.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight, timestamp or 0))\n            self.reverse_edges[src].append((dst, rel, weight, timestamp or 0))\n        \n        # Invalidate cache when graph changes\n        self.inference_cache.clear()\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n        self.inference_cache.clear()\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n        self.inference_cache.clear()\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        cache_key = (start, max_depth, decay, min_score, tuple(relation_filter) if relation_filter else None)\n        if cache_key in self.inference_cache:\n            return self.inference_cache[cache_key]\n        \n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            if depth < max_depth:\n                for dst, rel, weight, timestamp in self.edges[node]:\n                    if relation_filter and rel not in relation_filter:\n                        continue\n                    \n                    new_score = score * decay * weight * self.relation_weights[rel]\n                    if new_score >= min_score:\n                        queue.append((dst, new_score, depth + 1, paths[node]))\n        \n        result = (",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 3,
        "parent_id": "29d216b8ef85",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T08:50:19.698872"
      },
      {
        "id": "30bfefc307c9",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "e9713c5ab033d8c4",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                if dst not in path:  # Prevent cycles\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_paths(self, start, end, max_depth=3, max_paths=10):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * w * rel_weight\n                    queue.append((dst, path + [dst], new_score, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_neighbors(s",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "35f1fedc1317",
        "source_paper": "2602.15802v1",
        "created_at": "2026-02-18T08:54:08.315659"
      },
      {
        "id": "0cae5f994d52",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "84b539f164e91fe2",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        if bidirectional:\n            self.edges[dst].append((src, f\"inv_{rel}\", weight))\n            self.reverse_edges[src].append((dst, f\"inv_{rel}\", weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        paths = {}\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            current_score = score * self.node_weights[node]\n            visited[node] = round(current_score, 4)\n            paths[node] = path + [node]\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    if relation_filter and rel not in relation_filter:\n                        continue\n                    rel_weight = self.relation_weights[rel]\n                    new_score = current_score * weight * rel_weight * (decay ** depth)\n                    queue.append((dst, new_score, depth + 1, path + [node]))\n        \n        return visited, paths\n    \n    def find_connections(self, node1, node2, max_depth=4, max_paths=10):\n        \"\"\"Find all paths between two nodes with path ranking\"\"\"\n        paths = []\n        queue = deque([(node1, [node1], 1.0, 0)])\n        \n        while queue and len(paths) < max_paths:\n            current, path, score, depth = queue.popleft()\n            \n            if current == node2:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, weight in self.edges.get(current, []):\n                if dst not in path:\n                    rel_weight = self.relation_weights[rel]\n                    new_score = score * weight * rel_weight * (0.8 ** depth)\n                    queue.append((dst, path + [d",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "6e67fc4f4dd6",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-18T08:54:27.739010"
      },
      {
        "id": "2a8666b26379",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "df1203aa129080d5",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = round(score * self.node_weights[node], 4)\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_score = score * w * decay\n                    queue.append((dst, new_score, depth + 1, path + [dst]))\n        \n        return dict(sorted(visited.items(), key=lambda x: x[1], reverse=True))\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue:\n            node, path, score, depth = queue.popleft()\n            \n            if node == end:\n                paths.append((path, round(score, 4)))\n                continue\n            if depth >= max_depth:\n                continue\n                \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:\n                    queue.append((dst, path + [dst], score * w, depth + 1))\n        \n        return sorted(paths, key=lambda x: x[1], reverse=True)\n    \n    def get_related(self, node, relation_filter=None, direction='outgoing'):\n        edges_dict = self.edges if direction == 'outgoing' else self.reverse_edges\n        related = []\n        \n        for dst, rel, w in edges_dict.get(node, []):\n            if relation_filter is None or rel in relation_filter:\n                related.append((dst, rel, w))\n        \n        return sorted(related, key=lambda x: x[2], reverse=True)\n    \n    def compute_centrality(self):\n        centrality = defaultdict(float)\n        all_nodes = set(self.edges.keys()) | set(self.reverse_edges.keys())\n        \n        for node in all_nodes:\n            out_degree = len(self.edges[node])\n            in_degree = len(self.reverse_edges[node])\n            centrality[node] = math.sqrt(out_degree * in_",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "10c855caa01d",
        "source_paper": "2602.15811v1",
        "created_at": "2026-02-18T08:58:09.461438"
      },
      {
        "id": "7a6fae617978",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "095c0ca8a17438b5",
        "code_snippet": "import collections\nfrom typing import Dict, List, Set, Tuple, Optional\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.nodes: Dict[str, Dict] = {}\n        self.edges: Dict[str, List[Tuple[str, str, float]]] = collections.defaultdict(list)\n        self.reverse_edges: Dict[str, List[Tuple[str, str, float]]] = collections.defaultdict(list)\n        self.entity_embeddings: Dict[str, List[float]] = {}\n        \n    def add_entity(self, entity_id: str, properties: Dict = None) -> None:\n        \"\"\"Add an entity node to the knowledge graph.\"\"\"\n        self.nodes[entity_id] = properties or {}\n        \n    def add_relation(self, source: str, target: str, relation_type: str, weight: float = 1.0) -> None:\n        \"\"\"Add a directed relation between entities.\"\"\"\n        if source not in self.nodes:\n            self.add_entity(source)\n        if target not in self.nodes:\n            self.add_entity(target)\n            \n        self.edges[source].append((target, relation_type, weight))\n        self.reverse_edges[target].append((source, relation_type, weight))\n        \n    def find_paths(self, source: str, target: str, max_depth: int = 3) -> List[List[str]]:\n        \"\"\"Find all paths between two entities within max_depth.\"\"\"\n        if source not in self.nodes or target not in self.nodes:\n            return []\n            \n        paths = []\n        visited = set()\n        \n        def dfs(current: str, path: List[str], depth: int):\n            if depth > max_depth:\n                return\n            if current == target and len(path) > 1:\n                paths.append(path.copy())\n                return\n            if current in visited:\n                return\n                \n            visited.add(current)\n            for neighbor, relation, weight in self.edges[current]:\n                path.append(neighbor)\n                dfs(neighbor, path, depth + 1)\n                path.pop()\n            visited.remove(current)\n            \n        dfs(source, [source], 0)\n        return paths\n    \n    def get_neighbors(self, entity_id: str, relation_filter: Set[str] = None) -> List[Tuple[str, str, float]]:\n        \"\"\"Get all neighbors of an entity, optionally filtered by relation type.\"\"\"\n        if entity_id not in self.nodes:\n            return []\n            \n        neighbors = self.edges[entity_id]\n        if relation_filter:\n            neighbors = [(target, rel, weight) for target, rel, weight in neighbors \n                        if rel in relation_filter]\n        return neighbors\n    \n    def compute_centrality(self, entity_id: str) -> float:\n        \"\"\"Compute a simple centrality score based on in/out degree.\"\"\"\n        if entity_id not in self.nodes:\n            return 0.0\n            \n        out_degree = len(self.edges[entity_id])\n        in_degree = len(self.reverse_edges[entity_id])\n        return (out_degree + in_degree) / max(1, len(self.nodes) - 1)\n    \n    def query_subgraph(self, center_entity: str, radius: int = 2) -> 'KnowledgeGraph':\n   ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "7f2945a2bbbf",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-18T08:58:27.476015"
      },
      {
        "id": "88d2bed3ab06",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2_gen3",
        "module": "knowledge.graph",
        "code_hash": "5daf799255fb1ae3",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\nimport heapq\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_attributes = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.node_embeddings = {}\n        self.clusters = defaultdict(set)\n        self.temporal_edges = defaultdict(list)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, attributes=None, timestamp=None):\n        edge_data = (dst, rel, weight, timestamp)\n        self.edges[src].append(edge_data)\n        self.reverse_edges[dst].append((src, rel, weight, timestamp))\n        self.relation_types.add(rel)\n        \n        if timestamp:\n            self.temporal_edges[timestamp].append((src, rel, dst, weight))\n        \n        if attributes:\n            self.node_attributes[src].update(attributes.get('src', {}))\n            self.node_attributes[dst].update(attributes.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight, timestamp))\n            self.reverse_edges[src].append((dst, rel, weight, timestamp))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def set_node_embedding(self, node, embedding):\n        self.node_embeddings[node] = embedding\n    \n    def compute_centrality(self, node):\n        in_degree = len(self.reverse_edges[node])\n        out_degree = len(self.edges[node])\n        return math.log(1 + in_degree + out_degree) * self.node_weights[node]\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, use_centrality=True):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n            \n            centrality_boost = self.compute_centrality(node) if use_centrality else 1.0\n            final_score = score * self.node_weights[node] * centrality_boost\n            visited[node] = round(final_score, 4)\n            \n            for edge_data in self.edges.get(node, []):\n                dst, rel, w = edge_data[:3]\n                if dst in path:\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                    \n                relation_boost = self.relation_weights[rel]\n                new_score = score * decay * w * relation_boost\n                queue.append((dst, new_score, depth + 1, path + [dst]))\n        \n        return di",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 3,
        "parent_id": "d8a64f8bca75",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T09:02:19.507492"
      },
      {
        "id": "350b399e0f70",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "0ecb0b1dfe1c77cf",
        "code_snippet": "import collections\nfrom typing import List, Set, Dict, Tuple, Optional\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.nodes = {}\n        self.edges = collections.defaultdict(set)\n        self.reverse_edges = collections.defaultdict(set)\n        self.node_attributes = collections.defaultdict(dict)\n        self.edge_weights = {}\n    \n    def add_node(self, node_id: str, attributes: Dict = None):\n        \"\"\"Add a node with optional attributes to the knowledge graph.\"\"\"\n        self.nodes[node_id] = True\n        if attributes:\n            self.node_attributes[node_id].update(attributes)\n    \n    def add_edge(self, source: str, target: str, weight: float = 1.0, relation: str = \"related\"):\n        \"\"\"Add a weighted edge between two nodes with a relation type.\"\"\"\n        if source not in self.nodes:\n            self.add_node(source)\n        if target not in self.nodes:\n            self.add_node(target)\n        \n        edge_key = (source, target, relation)\n        self.edges[source].add((target, relation))\n        self.reverse_edges[target].add((source, relation))\n        self.edge_weights[edge_key] = weight\n    \n    def find_shortest_path(self, start: str, end: str) -> Optional[List[str]]:\n        \"\"\"Find shortest path between two nodes using BFS.\"\"\"\n        if start not in self.nodes or end not in self.nodes:\n            return None\n        \n        queue = collections.deque([(start, [start])])\n        visited = {start}\n        \n        while queue:\n            current, path = queue.popleft()\n            \n            if current == end:\n                return path\n            \n            for neighbor, _ in self.edges[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return None\n    \n    def get_neighbors(self, node_id: str, relation: str = None) -> Set[str]:\n        \"\"\"Get all neighbors of a node, optionally filtered by relation type.\"\"\"\n        if node_id not in self.nodes:\n            return set()\n        \n        neighbors = set()\n        for target, rel in self.edges[node_id]:\n            if relation is None or rel == relation:\n                neighbors.add(target)\n        \n        return neighbors\n    \n    def compute_centrality(self, node_id: str) -> float:\n        \"\"\"Compute degree centrality for a node.\"\"\"\n        if node_id not in self.nodes:\n            return 0.0\n        \n        total_nodes = len(self.nodes)\n        if total_nodes <= 1:\n            return 0.0\n        \n        degree = len(self.edges[node_id]) + len(self.reverse_edges[node_id])\n        return degree / (total_nodes - 1)\n    \n    def query_subgraph(self, center_node: str, max_depth: int = 2) -> Dict:\n        \"\"\"Extract a subgraph around a center node up to max_depth.\"\"\"\n        if center_node not in self.nodes:\n            return {\"nodes\": [], \"edges\": []}\n        \n        visited_nodes = set()\n        subgraph_edges = []\n        queue = ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "7f2945a2bbbf",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-18T09:02:49.917979"
      },
      {
        "id": "0148fe5c1bcd",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "edf2a6fa86d5bbef",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_weights = defaultdict(lambda: 1.0)\n    \n    def add(self, src, rel, dst, weight=1.0):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n    \n    def set_node_importance(self, node, importance):\n        self.node_weights[node] = importance\n    \n    def set_relation_strength(self, relation, strength):\n        self.relation_weights[relation] = strength\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            # Apply node importance weighting\n            final_score = score * self.node_weights[node]\n            visited[node] = {\n                'score': round(final_score, 4),\n                'depth': depth,\n                'path': path.copy()\n            }\n            \n            # Explore neighbors\n            for dst, rel, edge_weight in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    rel_strength = self.relation_weights[rel]\n                    new_score = score * edge_weight * rel_strength * decay\n                    new_path = path + [node]\n                    queue.append((dst, new_score, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], 1.0, 0)])\n        \n        while queue:\n            node, path, score, depth = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if node == end:\n                paths.append({\n                    'path': path,\n                    'score': round(score, 4),\n                    'length': len(path) - 1\n                })\n                continue\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst not in path:\n                    new_path = path + [dst]\n                    new_score = score * weight * self.relation_weights[rel]\n                    queue.append((dst, new_path, new_score, depth + 1))\n        \n        return sorted(paths, key=lambda x: x['score'], reverse=True)\n    \n    def get_neighbors(self, node, direction='out'):\n        if direction == 'out':\n            return [(dst, rel, w) for dst, rel, w in self.edges.get(node, [])]\n        elif direction == 'in':\n            return [(src, rel, w) for src, rel, w in self.reverse_edges.get(node, [])]\n        else:\n            return (self.get_neighbors(node, '",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "fc04ce7d8615",
        "source_paper": "2602.14970v1",
        "created_at": "2026-02-18T09:06:47.530875"
      },
      {
        "id": "6340643f51e9",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2_gen3",
        "module": "knowledge.graph",
        "code_hash": "d3562359b4744aa1",
        "code_snippet": "from collections import defaultdict, deque\nimport math\nimport json\nimport heapq\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n        self.node_metadata = defaultdict(dict)\n        self.relation_weights = defaultdict(lambda: 1.0)\n        self.node_embeddings = {}\n        self.clusters = defaultdict(set)\n        self.temporal_edges = defaultdict(list)\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False, metadata=None, timestamp=None):\n        edge_data = (dst, rel, weight, timestamp)\n        self.edges[src].append(edge_data)\n        self.reverse_edges[dst].append((src, rel, weight, timestamp))\n        self.relation_types.add(rel)\n        \n        if timestamp:\n            self.temporal_edges[timestamp].append((src, rel, dst, weight))\n        \n        if metadata:\n            self.node_metadata[src].update(metadata.get('src', {}))\n            self.node_metadata[dst].update(metadata.get('dst', {}))\n        \n        if bidirectional:\n            self.edges[dst].append((src, rel, weight, timestamp))\n            self.reverse_edges[src].append((dst, rel, weight, timestamp))\n    \n    def set_node_weight(self, node, weight):\n        self.node_weights[node] = weight\n    \n    def set_relation_weight(self, relation, weight):\n        self.relation_weights[relation] = weight\n    \n    def set_node_embedding(self, node, embedding):\n        self.node_embeddings[node] = embedding\n    \n    def add_to_cluster(self, cluster_id, node):\n        self.clusters[cluster_id].add(node)\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None, boost_nodes=None, temporal_window=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [start])])\n        boost_nodes = boost_nodes or set()\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited and visited[node] >= score:\n                continue\n            if depth > max_depth or score < min_score:\n                continue\n            \n            node_boost = 1.5 if node in boost_nodes else 1.0\n            final_score = score * self.node_weights[node] * node_boost\n            visited[node] = round(final_score, 4)\n            \n            for edge_data in self.edges.get(node, []):\n                dst, rel, w = edge_data[0], edge_data[1], edge_data[2]\n                timestamp = edge_data[3] if len(edge_data) > 3 else None\n                \n                if dst in path:\n                    continue\n                if relation_filter and rel not in relation_filter:\n                    continue\n                if temporal_window and timestamp and not (temporal_window[0] <= timestamp <= temporal_window[1]):\n                    continue\n                \n                rel_weight = self.relation_weights[rel]\n             ",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 3,
        "parent_id": "0a15e4251a6b",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T09:07:08.303020"
      },
      {
        "id": "c07aa165bff2",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "2d53244f12ff5e70",
        "code_snippet": "from collections import defaultdict, deque\nimport json\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_metadata = {}\n        \n    def add(self, src, rel, dst, weight=1.0, metadata=None):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        if metadata:\n            self.node_metadata[src] = self.node_metadata.get(src, {})\n            self.node_metadata[src].update(metadata)\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = {\n                'score': round(score, 4),\n                'depth': depth,\n                'path': path.copy()\n            }\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in path:  # Prevent cycles\n                    new_path = path + [rel]\n                    queue.append((dst, score * w * decay, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [start], [])])\n        \n        while queue:\n            node, path, relations = queue.popleft()\n            \n            if len(path) > max_depth + 1:\n                continue\n                \n            if node == end and len(path) > 1:\n                paths.append({\n                    'path': path,\n                    'relations': relations,\n                    'strength': self._calculate_path_strength(path, relations)\n                })\n                continue\n            \n            for dst, rel, weight in self.edges.get(node, []):\n                if dst not in path:\n                    queue.append((dst, path + [dst], relations + [(rel, weight)]))\n        \n        return sorted(paths, key=lambda x: x['strength'], reverse=True)\n    \n    def _calculate_path_strength(self, path, relations):\n        if not relations:\n            return 0.0\n        strength = 1.0\n        for _, weight in relations:\n            strength *= weight\n        return strength * (0.9 ** (len(path) - 2))  # Length penalty\n    \n    def get_neighbors(self, node, direction='out'):\n        if direction == 'out':\n            return [(dst, rel, w) for dst, rel, w in self.edges.get(node, [])]\n        elif direction == 'in':\n            return [(src, rel, w) for src, rel, w in self.reverse_edges.get(node, [])]\n        else:\n            return (self.get_neighbors(node, 'out') + \n                   self.get_neighbors(node, 'in'))\n    \n    def cluster_analysis(self, node, radius=2):\n        cluster = self.traverse(node, max_depth=radius, min_score=0.05)\n",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "354217f95e79",
        "source_paper": "2602.15791v1",
        "created_at": "2026-02-18T09:10:47.716765"
      },
      {
        "id": "01aff3b05be8",
        "strategy_name": "Softmax Diversity Scorer_gen1_gen2",
        "module": "knowledge.semantic",
        "code_hash": "6609cf3ecd515100",
        "code_snippet": "import math\nimport random\nfrom collections import defaultdict, deque\nimport json\n\nclass SemanticScorer:\n    def __init__(self, temperature=0.3, diversity_weight=0.2, memory_size=100):\n        self.temperature = max(temperature, 0.01)\n        self.diversity_weight = diversity_weight\n        self.history = defaultdict(float)\n        self.recent_selections = deque(maxlen=memory_size)\n        self.context_embeddings = {}\n        self.semantic_clusters = defaultdict(set)\n        self.decay_factor = 0.95\n        \n    def softmax_score(self, values, labels=None, context=None):\n        if not values: return []\n        \n        # Apply temperature scaling with context awareness\n        temp = self._adaptive_temperature(context)\n        exp_vals = [math.exp(v / temp) for v in values]\n        total = sum(exp_vals)\n        base_scores = [v / total for v in exp_vals]\n        \n        if labels and len(labels) == len(values):\n            # Multi-factor scoring\n            diversity_bonus = self._calculate_diversity_bonus(labels)\n            semantic_bonus = self._calculate_semantic_bonus(labels, context)\n            recency_penalty = self._calculate_recency_penalty(labels)\n            \n            adjusted_scores = []\n            for i, score in enumerate(base_scores):\n                label = labels[i]\n                diversity_mult = 1 + self.diversity_weight * diversity_bonus.get(label, 0)\n                semantic_mult = 1 + 0.15 * semantic_bonus.get(label, 0)\n                recency_mult = 1 - 0.1 * recency_penalty.get(label, 0)\n                \n                final_score = score * diversity_mult * semantic_mult * recency_mult\n                adjusted_scores.append(max(final_score, 0.001))  # Prevent zero scores\n            \n            # Renormalize with smoothing\n            total_adjusted = sum(adjusted_scores)\n            return [s / total_adjusted for s in adjusted_scores]\n        \n        return base_scores\n    \n    def _adaptive_temperature(self, context=None):\n        # Calculate entropy of recent selections\n        if len(self.recent_selections) < 2:\n            return self.temperature\n            \n        freq_dist = defaultdict(int)\n        for selection in self.recent_selections:\n            freq_dist[selection] += 1\n            \n        total = len(self.recent_selections)\n        entropy = -sum((count/total) * math.log2(count/total) \n                      for count in freq_dist.values() if count > 0)\n        \n        # Context-aware temperature adjustment\n        context_factor = 1.0\n        if context and hasattr(context, 'uncertainty'):\n            context_factor = 1 + context.uncertainty * 0.3\n            \n        base_temp = 0.2 + entropy * 0.25\n        return max(0.05, min(1.2, base_temp * context_factor))\n    \n    def _calculate_diversity_bonus(self, labels):\n        bonus = {}\n        total_selections = sum(self.history.values()) + 1\n        \n        for label in set(labels):\n            frequency = self.history[label]\n            # Inv",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "41da09bc48be",
        "source_paper": "2602.15021v1",
        "created_at": "2026-02-18T09:17:01.161352"
      },
      {
        "id": "41ac24995e42",
        "strategy_name": "Weighted Graph Traverser_gen1_gen2",
        "module": "knowledge.graph",
        "code_hash": "2acd70e1636d1a93",
        "code_snippet": "import collections\nfrom functools import lru_cache\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.nodes = {}\n        self.edges = collections.defaultdict(set)\n        self.reverse_edges = collections.defaultdict(set)\n        self.node_attributes = collections.defaultdict(dict)\n        self.edge_attributes = collections.defaultdict(dict)\n    \n    def add_node(self, node_id, **attributes):\n        \"\"\"Add a node with optional attributes to the knowledge graph.\"\"\"\n        self.nodes[node_id] = True\n        if attributes:\n            self.node_attributes[node_id].update(attributes)\n    \n    def add_edge(self, source, target, relation=None, **attributes):\n        \"\"\"Add a directed edge between nodes with optional relation and attributes.\"\"\"\n        self.add_node(source)\n        self.add_node(target)\n        edge_key = (source, target, relation)\n        self.edges[source].add((target, relation))\n        self.reverse_edges[target].add((source, relation))\n        if attributes:\n            self.edge_attributes[edge_key].update(attributes)\n    \n    def get_neighbors(self, node_id, relation=None):\n        \"\"\"Get all neighbors of a node, optionally filtered by relation.\"\"\"\n        if relation is None:\n            return [target for target, _ in self.edges[node_id]]\n        return [target for target, rel in self.edges[node_id] if rel == relation]\n    \n    def get_predecessors(self, node_id, relation=None):\n        \"\"\"Get all nodes that point to this node.\"\"\"\n        if relation is None:\n            return [source for source, _ in self.reverse_edges[node_id]]\n        return [source for source, rel in self.reverse_edges[node_id] if rel == relation]\n    \n    @lru_cache(maxsize=1000)\n    def shortest_path(self, source, target):\n        \"\"\"Find shortest path between two nodes using BFS.\"\"\"\n        if source == target:\n            return [source]\n        \n        queue = collections.deque([(source, [source])])\n        visited = {source}\n        \n        while queue:\n            current, path = queue.popleft()\n            \n            for neighbor, _ in self.edges[current]:\n                if neighbor == target:\n                    return path + [neighbor]\n                \n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return None\n    \n    def find_patterns(self, pattern_length=3):\n        \"\"\"Find common structural patterns in the graph.\"\"\"\n        patterns = collections.defaultdict(int)\n        \n        for node in self.nodes:\n            neighbors = self.get_neighbors(node)\n            if len(neighbors) >= pattern_length - 1:\n                # Create pattern signature based on node degrees\n                signature = tuple(sorted([len(self.get_neighbors(n)) for n in neighbors[:pattern_length-1]]))\n                patterns[signature] += 1\n        \n        return dict(patterns)\n    \n    def cluster_nodes(self, similarity_threshold=0.5)",
        "fitness_scores": [
          1.0,
          1.0,
          1.0,
          1.0,
          1.0
        ],
        "current_fitness": 1.0,
        "generation": 2,
        "parent_id": "7f2945a2bbbf",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-19T19:26:55.553369"
      },
      {
        "id": "f11b181bb692",
        "strategy_name": "Softmax Diversity Scorer_gen1_gen2_gen3",
        "module": "knowledge.semantic",
        "code_hash": "32a6b9a306cda948",
        "code_snippet": "import math\nimport random\nfrom collections import defaultdict, deque\nimport json\nimport re\n\nclass SemanticScorer:\n    def __init__(self, temperature=0.3, diversity_weight=0.2, memory_size=100):\n        self.temperature = max(temperature, 0.01)\n        self.diversity_weight = diversity_weight\n        self.history = defaultdict(float)\n        self.recent_selections = deque(maxlen=memory_size)\n        self.context_embeddings = {}\n        self.semantic_clusters = defaultdict(set)\n        self.decay_factor = 0.95\n        self.semantic_cache = {}\n        self.pattern_weights = defaultdict(float)\n        \n    def softmax_score(self, values, labels=None, context=None):\n        if not values: return []\n        \n        # Apply temperature scaling with context awareness\n        temp = self._adaptive_temperature(context)\n        exp_vals = [math.exp(min(v / temp, 700)) for v in values]  # Prevent overflow\n        total = sum(exp_vals)\n        base_scores = [v / total for v in exp_vals]\n        \n        if labels and len(labels) == len(values):\n            # Multi-factor scoring with enhanced semantic analysis\n            diversity_bonus = self._calculate_diversity_bonus(labels)\n            semantic_bonus = self._calculate_semantic_bonus(labels, context)\n            recency_penalty = self._calculate_recency_penalty(labels)\n            pattern_bonus = self._calculate_pattern_bonus(labels, context)\n            \n            adjusted_scores = []\n            for i, score in enumerate(base_scores):\n                label = labels[i]\n                diversity_mult = 1 + self.diversity_weight * diversity_bonus.get(label, 0)\n                semantic_mult = 1 + 0.15 * semantic_bonus.get(label, 0)\n                recency_mult = 1 - 0.1 * recency_penalty.get(label, 0)\n                pattern_mult = 1 + 0.1 * pattern_bonus.get(label, 0)\n                \n                final_score = score * diversity_mult * semantic_mult * recency_mult * pattern_mult\n                adjusted_scores.append(max(final_score, 0.001))\n            \n            # Renormalize with smoothing\n            total_adjusted = sum(adjusted_scores)\n            return [s / total_adjusted for s in adjusted_scores]\n        \n        return base_scores\n    \n    def _adaptive_temperature(self, context=None):\n        base_temp = self.temperature\n        if context:\n            # Adjust temperature based on context complexity\n            complexity = self._estimate_complexity(context)\n            return base_temp * (1 + 0.3 * complexity)\n        return base_temp\n    \n    def _estimate_complexity(self, context):\n        if isinstance(context, str):\n            # Simple complexity heuristic based on text features\n            word_count = len(context.split())\n            unique_words = len(set(context.lower().split()))\n            complexity = min(unique_words / max(word_count, 1), 1.0)\n            return complexity\n        return 0.5\n    \n    def _calculate_diversity_bonus(self, labels):\n        bonus = {}\n        ",
        "fitness_scores": [],
        "current_fitness": 1.0,
        "generation": 3,
        "parent_id": "01aff3b05be8",
        "source_paper": "2602.15021v1",
        "created_at": "2026-02-19T19:41:11.293297"
      },
      {
        "id": "15ad38188af0",
        "strategy_name": "Weighted Graph Traverser_gen1",
        "module": "knowledge.graph",
        "code_hash": "4cda6d46d14e5a4a",
        "code_snippet": "from collections import defaultdict, deque\nimport math\n\nclass KnowledgeGraph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.node_weights = defaultdict(lambda: 1.0)\n        self.relation_types = set()\n    \n    def add(self, src, rel, dst, weight=1.0, bidirectional=False):\n        self.edges[src].append((dst, rel, weight))\n        self.reverse_edges[dst].append((src, rel, weight))\n        self.relation_types.add(rel)\n        if bidirectional:\n            self.edges[dst].append((src, rel, weight))\n            self.reverse_edges[src].append((dst, rel, weight))\n    \n    def set_node_importance(self, node, importance):\n        self.node_weights[node] = importance\n    \n    def traverse(self, start, max_depth=3, decay=0.7, min_score=0.01, relation_filter=None):\n        visited = {}\n        queue = deque([(start, 1.0, 0, [])])\n        \n        while queue:\n            node, score, depth, path = queue.popleft()\n            \n            if node in visited or depth > max_depth or score < min_score:\n                continue\n                \n            visited[node] = {\n                'score': round(score * self.node_weights[node], 4),\n                'depth': depth,\n                'path': path.copy()\n            }\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if relation_filter and rel not in relation_filter:\n                    continue\n                if dst not in [p[0] for p in path]:  # Avoid cycles\n                    new_path = path + [(node, rel)]\n                    queue.append((dst, score * w * decay, depth + 1, new_path))\n        \n        return visited\n    \n    def find_paths(self, start, end, max_depth=3):\n        paths = []\n        queue = deque([(start, [(start, None)], 0)])\n        \n        while queue:\n            node, path, depth = queue.popleft()\n            \n            if depth > max_depth:\n                continue\n                \n            if node == end:\n                paths.append(path)\n                continue\n            \n            for dst, rel, w in self.edges.get(node, []):\n                if dst not in [p[0] for p in path]:\n                    new_path = path + [(dst, rel)]\n                    queue.append((dst, new_path, depth + 1))\n        \n        return paths\n    \n    def get_neighbors(self, node, direction='out'):\n        if direction == 'out':\n            return [(dst, rel, w) for dst, rel, w in self.edges.get(node, [])]\n        elif direction == 'in':\n            return [(src, rel, w) for src, rel, w in self.reverse_edges.get(node, [])]\n        else:\n            return (self.get_neighbors(node, 'out') + \n                   self.get_neighbors(node, 'in'))\n    \n    def compute_centrality(self):\n        centrality = defaultdict(float)\n        for node in set(list(self.edges.keys()) + list(self.reverse_edges.keys())):\n            out_degree = len(self.edges[node])\n            in_degree = len(self.rever",
        "fitness_scores": [],
        "current_fitness": 1.0,
        "generation": 1,
        "parent_id": "5dd2ab6f4ab8",
        "source_paper": "2602.15008v1",
        "created_at": "2026-02-19T19:41:27.222481"
      }
    ]
  }
}
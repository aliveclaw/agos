"""Tool Registry â€” central registry of all tools agents can use."""

from __future__ import annotations

import time
from typing import Any, Callable, Awaitable

from pydantic import BaseModel

from agos.tools.schema import ToolSchema
from agos.exceptions import ToolNotFoundError, ToolExecutionError

ToolHandler = Callable[..., Awaitable[Any]]


class ToolExecutionResult(BaseModel):
    tool_name: str
    success: bool
    result: Any = None
    error: str | None = None
    execution_time_ms: float = 0.0


class ToolRegistry:
    """Central registry of all tools available in the system.

    Tools are registered with a schema and an async handler.
    The registry provides discovery (list/search) and execution.
    """

    def __init__(self) -> None:
        self._tools: dict[str, tuple[ToolSchema, ToolHandler]] = {}

    def register(self, schema: ToolSchema, handler: ToolHandler) -> None:
        self._tools[schema.name] = (schema, handler)

    def unregister(self, tool_name: str) -> None:
        self._tools.pop(tool_name, None)

    def list_tools(self) -> list[ToolSchema]:
        return [schema for schema, _ in self._tools.values()]

    def get_anthropic_tools(self) -> list[dict]:
        """Get all tools in Anthropic API format."""
        return [schema.to_anthropic_tool() for schema, _ in self._tools.values()]

    async def execute(self, tool_name: str, arguments: dict) -> ToolExecutionResult:
        """Execute a tool by name with the given arguments."""
        entry = self._tools.get(tool_name)
        if entry is None:
            raise ToolNotFoundError(f"Tool '{tool_name}' not found")

        schema, handler = entry
        start = time.monotonic()

        try:
            result = await handler(**arguments)
            elapsed = (time.monotonic() - start) * 1000
            return ToolExecutionResult(
                tool_name=tool_name,
                success=True,
                result=result,
                execution_time_ms=elapsed,
            )
        except Exception as e:
            elapsed = (time.monotonic() - start) * 1000
            return ToolExecutionResult(
                tool_name=tool_name,
                success=False,
                error=f"{type(e).__name__}: {e}",
                execution_time_ms=elapsed,
            )

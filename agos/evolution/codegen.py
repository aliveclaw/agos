"""CodeEvolver — writes sandbox-passed patterns as real Python modules.

When the evolution engine discovers a code pattern from arxiv/GitHub that
passes sandbox testing, this module:

1. Wraps the pattern as a proper IntegrationStrategy subclass
2. Writes it to .agos/evolved/<name>.py
3. Registers it with the integrator for future evolution cycles

Each evolved module is a real, importable Python file that EXECUTES its
pattern code against live system components when apply() is called.
The code persists across restarts via the Docker volume.
"""

from __future__ import annotations

import ast
import hashlib
import importlib
import importlib.util
import logging
import re
from datetime import datetime
from pathlib import Path
from typing import Any

from agos.evolution.sandbox import Sandbox, SandboxResult

logger = logging.getLogger(__name__)

# Where evolved code lives (inside the persistent .agos workspace)
EVOLVED_DIR = Path(".agos/evolved")

# Module -> component attribute mapping for wiring evolved code
# Keys are agos_module targets, values are (registry_key, method_pairs)
MODULE_HOOKS: dict[str, dict[str, str]] = {
    "knowledge": {
        "component": "loom",
        "store_method": "episodic.store",
        "recall_method": "recall",
    },
    "knowledge.semantic": {
        "component": "loom.semantic",
        "store_method": "store",
        "recall_method": "recall",
    },
    "knowledge.graph": {
        "component": "loom.graph",
        "link_method": "link",
        "neighbors_method": "neighbors",
    },
    "knowledge.manager": {
        "component": "loom",
        "recall_method": "recall",
    },
    "intent": {
        "component": "audit_trail",
    },
    "intent.personas": {
        "component": "audit_trail",
    },
    "policy": {
        "component": "audit_trail",
    },
    "orchestration": {
        "component": "event_bus",
    },
    "orchestration.planner": {
        "component": "event_bus",
    },
}


def _sanitize_name(name: str) -> str:
    """Turn a pattern name into a valid Python module/class name."""
    clean = re.sub(r"[^a-zA-Z0-9_\s-]", "", name)
    clean = re.sub(r"[\s-]+", "_", clean).strip("_").lower()
    if clean and not clean[0].isalpha():
        clean = "evolved_" + clean
    return clean[:60] or "evolved_pattern"


def _extract_functions_and_classes(code: str) -> list[str]:
    """Extract top-level function/class names from code."""
    names = []
    try:
        tree = ast.parse(code)
        for node in ast.iter_child_nodes(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                names.append(node.name)
            elif isinstance(node, ast.ClassDef):
                names.append(node.name)
    except SyntaxError:
        pass
    return names


def _hash_pattern(code: str) -> str:
    """Hash the pattern code for deduplication."""
    # Normalize whitespace for comparison
    normalized = re.sub(r'\s+', ' ', code.strip())
    return hashlib.sha256(normalized.encode()).hexdigest()[:16]


def generate_strategy_module(
    pattern_name: str,
    pattern_code: str,
    source_paper: str,
    agos_module: str,
    sandbox_output: str,
) -> str:
    """Generate a strategy module where apply() EXECUTES the pattern code.

    The generated strategy:
    - Receives live system components via __init__(components=...)
    - Compiles and executes the pattern code in apply()
    - Hooks results into the target component
    - Reports what actually changed
    """
    mod_name = _sanitize_name(pattern_name)
    class_name = "".join(
        word.capitalize() for word in mod_name.split("_")
    ) + "Strategy"

    defined = _extract_functions_and_classes(pattern_code)
    defines_str = ", ".join(defined[:5]) if defined else "inline logic"
    code_hash = _hash_pattern(pattern_code)

    # Use repr() for safe string embedding — handles all escaping correctly
    pattern_repr = repr(pattern_code)

    # Build the module as a list of lines then join
    lines = [
        f'"""Evolved strategy: {pattern_name}',
        '',
        'Auto-generated by agos evolution engine.',
        f'Source paper: {source_paper}',
        f'Target module: {agos_module}',
        f'Generated: {datetime.utcnow().isoformat()}',
        f'Defines: {defines_str}',
        f'Code hash: {code_hash}',
        '',
        f'Sandbox output: {sandbox_output[:200]}',
        '"""',
        '',
        'from __future__ import annotations',
        '',
        'import logging',
        'from typing import Any',
        '',
        'from agos.evolution.integrator import IntegrationStrategy, EvolutionProposal',
        '',
        '_logger = logging.getLogger(__name__)',
        '',
        '# ── Evolved pattern code ──────────────────────────────────────────',
        '# This code passed sandbox validation and EXECUTES when apply() is called.',
        '',
        f'PATTERN_CODE = {pattern_repr}',
        '',
        f'PATTERN_HASH = "{code_hash}"',
        '',
        '',
        'def _execute_pattern() -> dict[str, Any]:',
        '    """Execute the pattern code and return all defined names."""',
        '    namespace = {"__builtins__": __builtins__}',
        f'    exec(compile(PATTERN_CODE, "<evolved:{mod_name}>", "exec"), namespace)',
        '    return {k: v for k, v in namespace.items()',
        '            if not k.startswith("_") and k != "__builtins__"}',
        '',
        '',
        '# ── Strategy wrapper ──────────────────────────────────────────────',
        '',
        '',
        f'class {class_name}(IntegrationStrategy):',
        f'    """Evolved strategy that EXECUTES: {pattern_name}"""',
        '',
        f'    name = "{mod_name}"',
        f'    target_module = "{agos_module}"',
        '',
        '    def __init__(self, components: dict[str, Any] | None = None, **kwargs: Any) -> None:',
        '        self._components = components or {}',
        '        self._applied = False',
        '        self._exports: dict[str, Any] = {}',
        '',
        '    def validate(self, proposal: EvolutionProposal) -> tuple[bool, str]:',
        '        return True, ""',
        '',
        '    async def snapshot(self) -> dict[str, Any]:',
        '        return {"applied": self._applied}',
        '',
        '    async def apply(self, proposal: EvolutionProposal) -> list[str]:',
        '        changes: list[str] = []',
        '',
        '        # Execute the pattern code for real',
        '        try:',
        '            self._exports = _execute_pattern()',
        '        except Exception as e:',
        f'            _logger.warning("Pattern execution failed for {mod_name}: %s", e)',
        '            return [f"Pattern execution failed: {e}"]',
        '',
        '        exported = [k for k in self._exports',
        '                    if callable(self._exports[k]) or isinstance(self._exports[k], type)]',
        '        if exported:',
        "            changes.append(f\"Executed pattern, defined: {', '.join(exported[:10])}\")",
        '        else:',
        '            changes.append("Executed pattern (no callable exports)")',
        '',
        '        # Hook into live system components',
        '        loom = self._components.get("loom")',
        '        event_bus = self._components.get("event_bus")',
        '        audit_trail = self._components.get("audit_trail")',
        f'        target = "{agos_module}"',
        '',
        '        # Wire exported functions/classes into the target component',
        '        if target.startswith("knowledge") and loom is not None:',
        '            semantic = getattr(loom, "semantic", None)',
        '            for fn_name, obj in self._exports.items():',
        '                if callable(obj) and not isinstance(obj, type):',
        '                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):',
        '                        setattr(semantic, f"_evolved_{fn_name}", obj)',
        '                        changes.append(f"Hooked {fn_name}() into semantic weave")',
        '                    elif not hasattr(loom, f"_evolved_{fn_name}"):',
        '                        setattr(loom, f"_evolved_{fn_name}", obj)',
        '                        changes.append(f"Hooked {fn_name}() into knowledge manager")',
        '                elif isinstance(obj, type):',
        '                    if semantic is not None and not hasattr(semantic, f"_evolved_{fn_name}"):',
        '                        setattr(semantic, f"_evolved_{fn_name}", obj)',
        '                        changes.append(f"Registered {fn_name} class in semantic weave")',
        '',
        '        elif target.startswith("intent") and audit_trail is not None:',
        '            for fn_name, obj in self._exports.items():',
        '                if callable(obj) and not isinstance(obj, type):',
        '                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):',
        '                        setattr(audit_trail, f"_evolved_{fn_name}", obj)',
        '                        changes.append(f"Hooked {fn_name}() into intent system")',
        '',
        '        elif target == "policy" and audit_trail is not None:',
        '            for fn_name, obj in self._exports.items():',
        '                if callable(obj) or isinstance(obj, type):',
        '                    if not hasattr(audit_trail, f"_evolved_{fn_name}"):',
        '                        setattr(audit_trail, f"_evolved_{fn_name}", obj)',
        '                        changes.append(f"Hooked {fn_name} into policy system")',
        '',
        '        elif target.startswith("orchestration") and event_bus is not None:',
        '            for fn_name, obj in self._exports.items():',
        '                if callable(obj) or isinstance(obj, type):',
        '                    if not hasattr(event_bus, f"_evolved_{fn_name}"):',
        '                        setattr(event_bus, f"_evolved_{fn_name}", obj)',
        '                        changes.append(f"Hooked {fn_name} into orchestration")',
        '',
        '        if not changes:',
        '            changes.append("Pattern executed but no hookable exports found")',
        '',
        '        self._applied = True',
        f'        changes.append("Source: {source_paper[:60]}")',
        '        return changes',
        '',
        '    async def rollback(self, snapshot_data: dict[str, Any]) -> None:',
        '        loom = self._components.get("loom")',
        '        event_bus = self._components.get("event_bus")',
        '        audit_trail = self._components.get("audit_trail")',
        '        for fn_name in self._exports:',
        '            for comp in [loom, getattr(loom, "semantic", None) if loom else None,',
        '                         event_bus, audit_trail]:',
        '                if comp is not None:',
        '                    attr = f"_evolved_{fn_name}"',
        '                    if hasattr(comp, attr):',
        '                        try:',
        '                            delattr(comp, attr)',
        '                        except Exception:',
        '                            pass',
        '        self._applied = snapshot_data.get("applied", False)',
        '',
        '    async def health_check(self) -> bool:',
        '        try:',
        '            _execute_pattern()',
        '            return True',
        '        except Exception:',
        '            return False',
    ]

    return '\n'.join(lines) + '\n'


async def _self_reflection_retry(
    code: str,
    error: str,
    llm_provider,
    sandbox: Sandbox,
    max_retries: int = 3,
) -> str | None:
    """On sandbox failure, ask LLM to fix the code. Up to max_retries attempts.

    Returns fixed code if any attempt passes sandbox, else None.
    ~600 tokens per retry.
    """
    current_code = code
    current_error = error
    for attempt in range(max_retries):
        prompt = (
            "This Python code failed sandbox validation. Fix it.\n\n"
            f"Code:\n```python\n{current_code[:2000]}\n```\n\n"
            f"Error:\n{current_error[:500]}\n\n"
            "Return ONLY the fixed Python code, no explanation.\n"
            "The code must be self-contained and use only safe imports "
            "(json, re, math, random, collections, etc)."
        )
        try:
            response = await llm_provider.complete(
                prompt, max_tokens=1500, temperature=0.2
            )
            # Extract code from markdown fences if present
            text = response.strip()
            if "```python" in text:
                start = text.index("```python") + 9
                end = text.index("```", start)
                text = text[start:end].strip()
            elif "```" in text:
                start = text.index("```") + 3
                end = text.index("```", start)
                text = text[start:end].strip()

            # Validate syntax
            ast.parse(text)

            # Test in sandbox
            result = await sandbox.test_pattern(text)
            if result.passed:
                logger.info(
                    "Self-reflection fixed code on attempt %d/%d",
                    attempt + 1, max_retries,
                )
                return text
            current_code = text
            current_error = result.error or result.output
        except Exception as e:
            current_error = str(e)
            continue

    return None


async def iterate_strategy(
    existing_code: str,
    fitness: float,
    signals: str,
    module: str,
    sandbox: Sandbox,
    llm_provider,
) -> str | None:
    """Generate an improved version of an existing strategy.

    Feeds the current code + fitness to LLM, asks for improvement.
    Validates in sandbox. Up to 3 retries with error feedback.
    ~1800 tokens per call.

    Returns improved code or None if all attempts fail.
    """
    prompt = (
        "You are improving a Python code pattern for an agentic OS component.\n\n"
        f"Target module: {module}\n"
        f"Current fitness score: {fitness:.2f} (0-1 scale, higher is better)\n"
        f"Recent performance signals: {signals[:300]}\n\n"
        f"Current code:\n```python\n{existing_code[:2000]}\n```\n\n"
        "Generate an IMPROVED version that should score higher.\n"
        "Rules:\n"
        "- Must be self-contained Python\n"
        "- Only safe imports (json, re, math, random, collections, etc)\n"
        "- Must define at least one function or class\n"
        "- Focus on the component's core capability\n"
        "Return ONLY the improved Python code."
    )

    for attempt in range(3):
        try:
            response = await llm_provider.complete(
                prompt, max_tokens=2000, temperature=0.4
            )
            text = response.strip()
            if "```python" in text:
                start = text.index("```python") + 9
                end = text.index("```", start)
                text = text[start:end].strip()
            elif "```" in text:
                start = text.index("```") + 3
                end = text.index("```", start)
                text = text[start:end].strip()

            # Validate syntax
            ast.parse(text)

            # Test in sandbox
            result = await sandbox.test_pattern(text)
            if result.passed:
                logger.info(
                    "iterate_strategy produced improved code on attempt %d",
                    attempt + 1,
                )
                return text

            # Feed error back to LLM for next attempt
            prompt = (
                f"The improved code failed sandbox:\n"
                f"Error: {result.error or result.output[:300]}\n\n"
                f"Fix and return ONLY the corrected Python code."
            )
        except Exception:
            continue

    return None


async def evolve_code(
    pattern_name: str,
    pattern_code: str,
    source_paper: str,
    agos_module: str,
    sandbox: Sandbox,
    sandbox_result: SandboxResult | None = None,
    llm_provider=None,
    max_retries: int = 3,
) -> dict[str, Any]:
    """The main code evolution function.

    1. Validates the pattern in sandbox (if not already done)
    1b. On failure, tries self-reflection retry if LLM available
    2. Checks for duplicate pattern code (skip if identical exists)
    3. Generates a strategy module wrapping the pattern
    4. Validates the generated source
    5. Writes it to .agos/evolved/
    6. Returns info about the evolved file

    Returns dict with: success, file_path, module_name, class_name, error
    """
    mod_name = _sanitize_name(pattern_name)
    class_name = "".join(
        word.capitalize() for word in mod_name.split("_")
    ) + "Strategy"

    result: dict[str, Any] = {
        "success": False,
        "file_path": "",
        "module_name": mod_name,
        "class_name": class_name,
        "error": "",
    }

    # Step 1: Ensure pattern passes sandbox
    if sandbox_result is None or not sandbox_result.passed:
        sandbox_result = await sandbox.test_pattern(pattern_code)
        if not sandbox_result.passed:
            # Step 1b: Self-reflection retry if LLM available
            if llm_provider is not None:
                fixed = await _self_reflection_retry(
                    pattern_code,
                    sandbox_result.error or sandbox_result.output,
                    llm_provider,
                    sandbox,
                    max_retries=max_retries,
                )
                if fixed is not None:
                    pattern_code = fixed
                    sandbox_result = await sandbox.test_pattern(pattern_code)
                else:
                    result["error"] = f"Pattern failed sandbox + {max_retries} retries"
                    return result
            else:
                result["error"] = f"Pattern failed sandbox: {sandbox_result.error[:200]}"
                return result

    # Step 2: Deduplicate — don't write if identical pattern code exists
    code_hash = _hash_pattern(pattern_code)
    EVOLVED_DIR.mkdir(parents=True, exist_ok=True)
    for existing in EVOLVED_DIR.glob("*.py"):
        if existing.name.startswith("_"):
            continue
        try:
            content = existing.read_text(encoding="utf-8")
            if f'PATTERN_HASH = "{code_hash}"' in content:
                result["error"] = f"Duplicate pattern (hash {code_hash}), skipping"
                logger.info("Skipping duplicate evolved pattern: %s (hash %s)", mod_name, code_hash)
                return result
        except Exception:
            continue

    # Step 3: Generate the strategy module
    source = generate_strategy_module(
        pattern_name=pattern_name,
        pattern_code=pattern_code,
        source_paper=source_paper,
        agos_module=agos_module,
        sandbox_output=sandbox_result.output[:200],
    )

    # Step 4: Validate generated source is valid Python
    try:
        ast.parse(source)
    except SyntaxError as e:
        result["error"] = f"Generated code has syntax error: {e}"
        return result

    # Step 5: Write to disk
    file_path = EVOLVED_DIR / f"{mod_name}.py"

    # Only create a new version if code is actually different
    if file_path.exists():
        for i in range(2, 20):
            alt = EVOLVED_DIR / f"{mod_name}_v{i}.py"
            if not alt.exists():
                file_path = alt
                mod_name = f"{mod_name}_v{i}"
                result["module_name"] = mod_name
                break

    file_path.write_text(source, encoding="utf-8")

    result["success"] = True
    result["file_path"] = str(file_path)

    logger.info("Evolved code written: %s (%s)", file_path, class_name)
    return result


def load_evolved_strategies(
    evolved_dir: Path | None = None,
    components: dict[str, Any] | None = None,
) -> list[Any]:
    """Dynamically load evolved strategy modules from disk.

    Args:
        evolved_dir: Directory with evolved .py files
        components: Live system components dict with keys like
            'loom', 'event_bus', 'audit_trail', 'sandbox'

    Returns list of (module_path, strategy_instance) tuples.
    """
    d = evolved_dir or EVOLVED_DIR
    if not d.exists():
        return []

    components = components or {}

    # Only load the latest version of each base pattern
    latest: dict[str, Path] = {}
    for py_file in sorted(d.glob("*.py")):
        if py_file.name.startswith("_"):
            continue
        # Extract base name (strip _v2, _v3, etc.)
        stem = py_file.stem
        base = re.sub(r'_v\d+$', '', stem)
        # Keep the latest (highest version or the original)
        latest[base] = py_file

    strategies = []
    for base_name, py_file in sorted(latest.items()):
        try:
            spec = importlib.util.spec_from_file_location(
                f"agos.evolved.{py_file.stem}", str(py_file)
            )
            if spec is None or spec.loader is None:
                continue
            mod = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(mod)

            for attr_name in dir(mod):
                attr = getattr(mod, attr_name)
                if (
                    isinstance(attr, type)
                    and attr_name.endswith("Strategy")
                    and attr_name != "IntegrationStrategy"
                    and hasattr(attr, "name")
                    and hasattr(attr, "target_module")
                ):
                    instance = attr(components=components)
                    strategies.append((str(py_file), instance))
                    logger.info(
                        "Loaded evolved strategy: %s from %s (with live components)",
                        attr_name, py_file.name,
                    )
                    break
        except Exception as e:
            logger.warning("Failed to load evolved module %s: %s", py_file, e)

    return strategies

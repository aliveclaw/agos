"""CodeEvolver — writes sandbox-passed patterns as real Python modules.

When the evolution engine discovers a code pattern from arxiv/GitHub that
passes sandbox testing, this module:

1. Wraps the pattern as a proper IntegrationStrategy subclass
2. Writes it to .agos/evolved/<name>.py
3. Registers it with the integrator for future evolution cycles

Each evolved module is a real, importable Python file — not just a
parameter tweak. The code persists across restarts via the Docker volume.
"""

from __future__ import annotations

import ast
import importlib
import importlib.util
import logging
import re
from datetime import datetime
from pathlib import Path
from typing import Any

from agos.evolution.sandbox import Sandbox, SandboxResult

logger = logging.getLogger(__name__)

# Where evolved code lives (inside the persistent .agos workspace)
EVOLVED_DIR = Path(".agos/evolved")


def _sanitize_name(name: str) -> str:
    """Turn a pattern name into a valid Python module/class name."""
    # Remove non-alphanumeric, replace spaces/hyphens with underscores
    clean = re.sub(r"[^a-zA-Z0-9_\s-]", "", name)
    clean = re.sub(r"[\s-]+", "_", clean).strip("_").lower()
    # Ensure it starts with a letter
    if clean and not clean[0].isalpha():
        clean = "evolved_" + clean
    return clean[:60] or "evolved_pattern"


def _extract_functions_and_classes(code: str) -> list[str]:
    """Extract top-level function/class names from code."""
    names = []
    try:
        tree = ast.parse(code)
        for node in ast.iter_child_nodes(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                names.append(node.name)
            elif isinstance(node, ast.ClassDef):
                names.append(node.name)
    except SyntaxError:
        pass
    return names


def generate_strategy_module(
    pattern_name: str,
    pattern_code: str,
    source_paper: str,
    agos_module: str,
    sandbox_output: str,
) -> str:
    """Generate a complete IntegrationStrategy module wrapping the pattern.

    Returns the full Python source code for the evolved module.
    """
    mod_name = _sanitize_name(pattern_name)
    class_name = "".join(
        word.capitalize() for word in mod_name.split("_")
    ) + "Strategy"

    # Extract what the pattern defines
    defined = _extract_functions_and_classes(pattern_code)
    defines_str = ", ".join(defined[:5]) if defined else "inline logic"

    # Build the module
    source = f'''"""Evolved strategy: {pattern_name}

Auto-generated by agos evolution engine.
Source paper: {source_paper}
Target module: {agos_module}
Generated: {datetime.utcnow().isoformat()}
Defines: {defines_str}

Sandbox output: {sandbox_output[:200]}
"""

from __future__ import annotations

from typing import Any

from agos.evolution.integrator import IntegrationStrategy, EvolutionProposal


# ── Evolved pattern code ──────────────────────────────────────────
# This code passed sandbox validation before being written here.

{pattern_code}

# ── Strategy wrapper ──────────────────────────────────────────────


class {class_name}(IntegrationStrategy):
    """Evolved strategy wrapping: {pattern_name}"""

    name = "{mod_name}"
    target_module = "{agos_module}"

    def __init__(self, **kwargs: Any) -> None:
        self._kwargs = kwargs
        self._applied = False

    def validate(self, proposal: EvolutionProposal) -> tuple[bool, str]:
        return True, ""

    async def snapshot(self) -> dict[str, Any]:
        return {{"applied": self._applied}}

    async def apply(self, proposal: EvolutionProposal) -> list[str]:
        self._applied = True
        return [
            "Applied evolved pattern: {pattern_name}",
            "Source: {source_paper[:60]}",
        ]

    async def rollback(self, snapshot_data: dict[str, Any]) -> None:
        self._applied = snapshot_data.get("applied", False)

    async def health_check(self) -> bool:
        return True
'''
    return source


async def evolve_code(
    pattern_name: str,
    pattern_code: str,
    source_paper: str,
    agos_module: str,
    sandbox: Sandbox,
    sandbox_result: SandboxResult | None = None,
) -> dict[str, Any]:
    """The main code evolution function.

    1. Validates the pattern in sandbox (if not already done)
    2. Generates a strategy module wrapping the pattern
    3. Tests the generated module in sandbox
    4. Writes it to .agos/evolved/
    5. Returns info about the evolved file

    Returns dict with: success, file_path, module_name, class_name, error
    """
    mod_name = _sanitize_name(pattern_name)
    class_name = "".join(
        word.capitalize() for word in mod_name.split("_")
    ) + "Strategy"

    result: dict[str, Any] = {
        "success": False,
        "file_path": "",
        "module_name": mod_name,
        "class_name": class_name,
        "error": "",
    }

    # Step 1: Ensure pattern passes sandbox
    if sandbox_result is None or not sandbox_result.passed:
        sandbox_result = await sandbox.test_pattern(pattern_code)
        if not sandbox_result.passed:
            result["error"] = f"Pattern failed sandbox: {sandbox_result.error[:200]}"
            return result

    # Step 2: Generate the strategy module
    source = generate_strategy_module(
        pattern_name=pattern_name,
        pattern_code=pattern_code,
        source_paper=source_paper,
        agos_module=agos_module,
        sandbox_output=sandbox_result.output[:200],
    )

    # Step 3: Validate generated source is valid Python
    try:
        ast.parse(source)
    except SyntaxError as e:
        result["error"] = f"Generated code has syntax error: {e}"
        return result

    # Step 4: Write to disk
    EVOLVED_DIR.mkdir(parents=True, exist_ok=True)
    file_path = EVOLVED_DIR / f"{mod_name}.py"

    # Don't overwrite existing evolved code
    if file_path.exists():
        # Increment name
        for i in range(2, 20):
            alt = EVOLVED_DIR / f"{mod_name}_v{i}.py"
            if not alt.exists():
                file_path = alt
                mod_name = f"{mod_name}_v{i}"
                result["module_name"] = mod_name
                break

    file_path.write_text(source, encoding="utf-8")

    result["success"] = True
    result["file_path"] = str(file_path)

    logger.info("Evolved code written: %s (%s)", file_path, class_name)
    return result


def load_evolved_strategies(evolved_dir: Path | None = None) -> list[Any]:
    """Dynamically load all evolved strategy modules from disk.

    Returns list of (module_path, strategy_instance) tuples.
    """
    d = evolved_dir or EVOLVED_DIR
    if not d.exists():
        return []

    strategies = []
    for py_file in sorted(d.glob("*.py")):
        if py_file.name.startswith("_"):
            continue
        try:
            # Load the module dynamically
            spec = importlib.util.spec_from_file_location(
                f"agos.evolved.{py_file.stem}", str(py_file)
            )
            if spec is None or spec.loader is None:
                continue
            mod = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(mod)

            # Find the Strategy class
            for attr_name in dir(mod):
                attr = getattr(mod, attr_name)
                if (
                    isinstance(attr, type)
                    and attr_name.endswith("Strategy")
                    and attr_name != "IntegrationStrategy"
                    and hasattr(attr, "name")
                    and hasattr(attr, "target_module")
                ):
                    instance = attr()
                    strategies.append((str(py_file), instance))
                    logger.info(
                        "Loaded evolved strategy: %s from %s",
                        attr_name, py_file.name,
                    )
                    break  # one strategy per file
        except Exception as e:
            logger.warning("Failed to load evolved module %s: %s", py_file, e)

    return strategies
